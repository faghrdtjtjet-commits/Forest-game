<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конструктор блок-схем</title>
    <style>
        /* Все предыдущие стили остаются без изменений */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        body.dark-theme {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }
        
        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        body.dark-theme .sidebar {
            background: #1a252f;
        }
        
        .sidebar-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
        }
        
        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #ecf0f1;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }
        
        button {
            padding: 12px 15px;
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .green-btn {
            background: #27ae60;
        }
        
        .green-btn:hover {
            background: #219653;
        }
        
        .gray-btn {
            background: #7f8c8d;
        }
        
        .gray-btn:hover {
            background: #6c7a7d;
        }
        
        .red-btn {
            background: #e74c3c;
        }
        
        .red-btn:hover {
            background: #c0392b;
        }
        
        input, textarea, select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 100%;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.9);
        }
        
        textarea {
            height: 80px;
            resize: vertical;
        }
        
        .canvas-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #ecf0f1;
            transition: background 0.3s ease;
        }

        body.dark-theme .canvas-area {
            background: #2c3e50;
        }
        
        .canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: auto;
            background: #f9f9f9;
            cursor: grab;
            transition: background 0.3s ease;
        }

        body.dark-theme .canvas-container {
            background: #34495e;
        }
        
        #canvas {
            position: relative;
            width: 4000px;
            height: 4000px;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
        }
        
        .grid-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        .connectors-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }
        
        .blocks-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        
        .block {
            position: absolute;
            background: white;
            border: 2px solid #27ae60;
            border-radius: 8px;
            padding: 15px;
            min-width: 150px;
            min-height: 80px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            cursor: move;
            user-select: none;
            transform-origin: center;
            display: flex;
            flex-direction: column;
            width: auto;
            max-width: 300px;
            word-wrap: break-word;
        }

        body.dark-theme .block {
            background: #2c3e50;
            color: #ecf0f1;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .block.image-only, .block.video-only {
            padding: 2px;
            min-width: 0;
            min-height: 0;
        }
        
        .block:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }
        
        .block.selected {
            border: 2px solid #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
        }
        
        .block.connecting {
            border: 2px solid #e74c3c;
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.3);
        }
        
        .block-header {
            font-weight: bold;
            margin-bottom: 8px;
            color: #27ae60;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            font-size: 16px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }

        body.dark-theme .block-header {
            color: #27ae60;
            border-bottom: 1px solid #4a6572;
        }
        
        .block-content {
            color: #2c3e50;
            font-weight: normal;
            font-size: 14px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
            flex-grow: 1;
        }

        body.dark-theme .block-content {
            color: #ecf0f1;
        }
        
        .block-image {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
            margin-top: 10px;
            border-radius: 4px;
        }
        
        .block-image-only, .block-video-only {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
            border-radius: 4px;
        }
        
        .block-video {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
            margin-top: 10px;
            border-radius: 4px;
            background: transparent;
        }
        
        .block-video-only {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
            border-radius: 4px;
            background: transparent;
        }
        
        .video-controls {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 3px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 15;
        }
        
        .block-video-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            height: 100%;
        }
        
        .block-video-wrapper:hover .video-controls {
            opacity: 1;
        }
        
        .video-control-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 2px 5px;
            font-size: 12px;
            border-radius: 3px;
            flex: 1;
        }
        
        .video-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .block-video::-webkit-media-controls {
            display: none !important;
        }
        
        .block-video-only::-webkit-media-controls {
            display: none !important;
        }
        
        .block-video {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        .block-video-only {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        .block-video::-webkit-media-controls-panel {
            display: none !important;
        }
        
        .block-video-only::-webkit-media-controls-panel {
            display: none !important;
        }
        
        /* Стили для соединений */
        .connector, .temp-connector {
            position: absolute;
            transform-origin: 0 0;
            z-index: 5;
            pointer-events: none;
        }
        
        .connector {
            stroke: #27ae60;
            fill: none;
        }
        
        .temp-connector {
            stroke: #e74c3c;
            fill: none;
        }
        
        .connector-path {
            stroke-width: 3;
        }
        
        .temp-connector-path {
            stroke-width: 3;
        }
        
        .connector.arrow .arrow-head {
            fill: #27ae60;
        }
        
        .edit-panel {
            position: fixed;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            min-width: 350px;
            min-height: 500px;
            max-width: 90vw;
            max-height: 90vh;
            resize: both;
            overflow: auto;
            cursor: default;
        }

        body.dark-theme .edit-panel {
            background: #2c3e50;
            color: #ecf0f1;
        }
        
        .edit-panel-header {
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            cursor: move;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        body.dark-theme .edit-panel-header {
            border-bottom: 1px solid #4a6572;
        }
        
        .edit-panel input, .edit-panel textarea, .edit-panel select {
            width: 100%;
            margin-bottom: 10px;
        }

        body.dark-theme .edit-panel input, 
        body.dark-theme .edit-panel textarea, 
        body.dark-theme .edit-panel select {
            background: #34495e;
            color: #ecf0f1;
            border: 1px solid #4a6572;
        }
        
        .edit-panel button {
            width: 100%;
        }
        
        .image-size-controls, .video-size-controls {
            display: none;
            margin-bottom: 10px;
        }
        
        .image-size-controls.show, .video-size-controls.show {
            display: block;
        }
        
        .image-size-input, .video-size-input {
            width: 100px;
            display: inline-block;
            margin-right: 10px;
        }
        
        .file-input {
            display: none;
        }
        
        .status-indicator {
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            margin-top: 10px;
        }
        
        .status-active {
            background-color: #27ae60;
            color: white;
        }
        
        .status-inactive {
            background-color: #e74c3c;
            color: white;
        }
        
        .mode-selectors {
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            width: 100%;
        }
        
        .mode-selector {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            color: #ecf0f1;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            width: 100%;
            text-align: left;
        }
        
        .mode-selector:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .mode-selector.active {
            background: #27ae60;
            color: white;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            background: #27ae60;
            color: white;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.error {
            background: #e74c3c;
        }
        
        .zoom-controls-sidebar {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            width: 100%;
        }
        
        .zoom-display-sidebar {
            text-align: center;
            font-weight: bold;
            color: #27ae60;
            transition: all 0.3s ease;
            font-size: 16px;
            margin: 10px 0;
            background: white;
            padding: 10px;
            border-radius: 5px;
        }

        body.dark-theme .zoom-display-sidebar {
            color: #27ae60;
            background: #2c3e50;
        }
        
        .zoom-btn-sidebar {
            width: 100%;
            height: 40px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            background: #27ae60;
            color: white;
            border: none;
            transition: all 0.3s ease;
        }
        
        .zoom-btn-sidebar:hover {
            background: #219653;
        }
        
        .help-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #27ae60;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            border: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        
        .help-btn:hover {
            background: #219653;
        }
        
        .help-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
        }

        body.dark-theme .help-panel {
            background: #2c3e50;
            color: #ecf0f1;
        }
        
        .help-panel h2 {
            margin-bottom: 10px;
            color: #27ae60;
        }
        
        .help-panel ul {
            padding-left: 20px;
        }
        
        .help-panel li {
            margin-bottom: 8px;
            line-height: 1.5;
            color: #27ae60;
        }

        body.dark-theme .help-panel li {
            color: #27ae60;
        }
        
        .help-panel button {
            width: 100%;
            margin-top: 10px;
        }
        
        .grid-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 5px;
            width: 100%;
        }
        
        .grid-input {
            width: 100px !important;
            text-align: center;
        }
        
        .grid-btn {
            padding: 8px 15px !important;
        }
        
        .grid-btn.active {
            background: #27ae60;
        }
        
        .style-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            width: 100%;
        }
        
        .color-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .color-input {
            width: 60px !important;
            height: 40px;
            padding: 0;
            border: none;
        }
        
        .font-controls {
            display: flex;
            gap: 5px;
        }
        
        .font-btn {
            padding: 8px 12px !important;
            flex: 1;
        }
        
        .font-btn.active {
            background: #27ae60;
        }
        
        .font-btn:not(.active) {
            background: #7f8c8d;
        }
        
        .style-section {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .style-section h4 {
            margin-bottom: 8px;
            color: #27ae60;
        }
        
        .border-width-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .border-width-input {
            width: 80px !important;
            text-align: center;
        }
        
        .divider-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .divider-checkbox {
            width: 20px !important;
            height: 20px;
        }
        
        .media-type-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .media-type-btn {
            padding: 8px 12px !important;
            flex: 1;
        }
        
        .media-type-btn.active {
            background: #27ae60;
        }
        
        .media-type-btn:not(.active) {
            background: #7f8c8d;
        }
        
        .toggle-sidebar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #27ae60;
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            border: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            display: none;
        }

        .connector-style-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            width: 100%;
        }

        .connector-style-btn {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            color: #ecf0f1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            width: 100%;
            text-align: left;
        }

        .connector-style-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .connector-style-btn.active {
            background: #27ae60;
            color: white;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }

        .theme-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            width: 100%;
        }

        .theme-btn {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            color: #ecf0f1;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            width: 100%;
            text-align: left;
        }

        .theme-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .theme-btn.active {
            background: #27ae60;
            color: white;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }
        
        .context-menu {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            min-width: 150px;
            overflow: hidden;
        }

        body.dark-theme .context-menu {
            background: #2c3e50;
            color: #ecf0f1;
        }
        
        .context-menu-item {
            padding: 12px 15px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .context-menu-item:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        body.dark-theme .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Новые стили для настроек режимов */
        .connector-settings {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .connector-settings.show {
            display: block;
        }
        
        .connector-setting {
            margin-bottom: 10px;
        }
        
        .connector-setting label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .connector-setting input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: -280px;
                height: 100%;
                transition: left 0.3s ease;
                z-index: 100;
            }
            
            .sidebar.open {
                left: 0;
            }
            
            .toggle-sidebar {
                display: flex;
            }
            
            .help-panel {
                max-width: 250px;
            }
        }
    </style>
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Open+Sans:wght@300;400;700&family=Montserrat:wght@300;400;700&family=Lato:wght@300;400;700&family=Source+Sans+Pro:wght@300;400;700&family=Oswald:wght@300;400;700&family=Raleway:wght@300;400;700&family=PT+Sans:wght@400;700&family=Merriweather:wght@300;400;700&family=Playfair+Display:wght@400;700&family=Roboto+Slab:wght@300;400;700&family=Noto+Sans:wght@300;400;700&display=swap" rel="stylesheet">
</head>
<body>
    <button class="help-btn" id="help-btn">?</button>
    <button class="toggle-sidebar" id="toggle-sidebar">☰</button>
    
    <div class="help-panel" id="help-panel">
        <h2>Как пользоваться:</h2>
        <ul>
            <li>Введите заголовок и содержимое блока, затем нажмите "Добавить блок"</li>
            <li>Загрузите изображение или видео с помощью соответствующих кнопок</li>
            <li><strong>Режим перемещения</strong>: перетаскивайте блоки, ухватившись за них пальцем или мышкой</li>
            <li><strong>Режим соединения</strong>: нажмите на блок и протяните линию к другому блоку (наведенный блок подсвечивается)</li>
            <li><strong>Повторное соединение тех же блоков</strong>: удаляет существующее соединение</li>
            <li>Для блоков с медиа можно задать размеры в панели редактирования</li>
            <li>Используйте кнопки "Сохранить проект" и "Загрузить проект" для работы с файлами</li>
            <li>Индикатор "Сохранено" показывает статус последнего сохранения</li>
            <li>Используйте кнопки +/- для изменения масштаба холста</li>
            <li>Перетаскивайте холст пальцем или мышью для навигации</li>
            <li>Окно редактирования можно перемещать и изменять его размер</li>
            <li><strong>Стили блоков</strong>: можно изменить цвет обводки, цвет текста, шрифт и стили текста</li>
            <li><strong>Привязка к сетке</strong>: включите кнопку "Сетка" и задайте размер ячейки для движения блоков по сетке</li>
            <li><strong>Новые возможности</strong>: загрузка видео, изменение ширины обводки, раздельное форматирование заголовка и текста, настройка разделительной линии</li>
            <li><strong>Редактирование блока</strong>: щелкните правой кнопкой мыши по блоку для открытия меню редактирования</li>
            <li><strong>Настройка соединений</strong>: в режиме соединения можно выбрать тип линии и настроить его параметры</li>
        </ul>
        <button id="close-help" class="red-btn">Закрыть</button>
    </div>
    
    <div class="app-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-section" id="add-block-section">
                <h2>Добавить блок</h2>
                <input type="text" id="block-title" placeholder="Заголовок блока">
                <textarea id="block-content" placeholder="Содержимое блока"></textarea>
                <button id="add-block" class="green-btn">Добавить блок</button>
                
                <div class="media-type-selector">
                    <button id="upload-image-btn" class="media-type-btn active">Изображение</button>
                    <button id="upload-video-btn" class="media-type-btn">Видео</button>
                </div>
                
                <input type="file" id="image-input" class="file-input" accept="image/*">
                <input type="file" id="video-input" class="file-input" accept="video/*">
            </div>
            
            <div class="sidebar-section connector-style-selector" id="connector-style-selector">
                <h2>Стиль соединений</h2>
                <button class="connector-style-btn active" data-style="straight">Прямая линия</button>
                <button class="connector-style-btn" data-style="arrow">Стрелка</button>
                <button class="connector-style-btn" data-style="zigzag">Зигзаг</button>
                <button class="connector-style-btn" data-style="wave">Волна</button>
                <button class="connector-style-btn" data-style="arc">Дуга</button>
                <button class="connector-style-btn" data-style="loop">Петля</button>
                
                <!-- Настройки для каждого типа соединения -->
                <div class="connector-settings" id="straight-settings">
                    <div class="connector-setting">
                        <label>Толщина линии:</label>
                        <input type="number" id="straight-width" min="1" max="10" value="3">
                    </div>
                </div>
                
                <div class="connector-settings" id="arrow-settings">
                    <div class="connector-setting">
                        <label>Толщина линии:</label>
                        <input type="number" id="arrow-width" min="1" max="10" value="3">
                    </div>
                    <div class="connector-setting">
                        <label>Размер стрелки:</label>
                        <input type="number" id="arrow-size" min="5" max="20" value="10">
                    </div>
                </div>
                
                <div class="connector-settings" id="zigzag-settings">
                    <div class="connector-setting">
                        <label>Толщина линии:</label>
                        <input type="number" id="zigzag-width" min="1" max="10" value="3">
                    </div>
                    <div class="connector-setting">
                        <label>Высота зигзага:</label>
                        <input type="number" id="zigzag-height" min="10" max="100" value="20">
                    </div>
                    <div class="connector-setting">
                        <label>Количество сегментов:</label>
                        <input type="number" id="zigzag-segments" min="3" max="20" value="8">
                    </div>
                </div>
                
                <div class="connector-settings" id="wave-settings">
                    <div class="connector-setting">
                        <label>Толщина линии:</label>
                        <input type="number" id="wave-width" min="1" max="10" value="3">
                    </div>
                    <div class="connector-setting">
                        <label>Высота волны:</label>
                        <input type="number" id="wave-height" min="10" max="100" value="30">
                    </div>
                    <div class="connector-setting">
                        <label>Количество волн:</label>
                        <input type="number" id="wave-count" min="2" max="20" value="6">
                    </div>
                </div>
                
                <div class="connector-settings" id="arc-settings">
                    <div class="connector-setting">
                        <label>Толщина линии:</label>
                        <input type="number" id="arc-width" min="1" max="10" value="3">
                    </div>
                    <div class="connector-setting">
                        <label>Высота дуги:</label>
                        <input type="number" id="arc-height" min="10" max="200" value="50">
                    </div>
                </div>
                
                <div class="connector-settings" id="loop-settings">
                    <div class="connector-setting">
                        <label>Толщина линии:</label>
                        <input type="number" id="loop-width" min="1" max="10" value="3">
                    </div>
                    <div class="connector-setting">
                        <label>Высота петли:</label>
                        <input type="number" id="loop-height" min="20" max="200" value="80">
                    </div>
                </div>
            </div>
            
            <div class="sidebar-section theme-controls" id="theme-controls">
                <h2>Тема холста</h2>
                <button class="theme-btn active" data-theme="light">Светлая тема</button>
                <button class="theme-btn" data-theme="dark">Тёмная тема</button>
            </div>
            
            <div class="sidebar-section">
                <h2>Режимы работы</h2>
                <div class="mode-selectors">
                    <button class="mode-selector active" data-mode="move">Перемещение</button>
                    <button class="mode-selector" data-mode="connect">Соединение</button>
                </div>
            </div>
            
            <div class="sidebar-section">
                <h2>Сетка</h2>
                <div class="grid-controls">
                    <div style="display: flex; gap: 5px; width: 100%; justify-content: center;">
                        <input type="number" id="grid-size-x" class="grid-input" value="10" min="1" max="100" step="1">
                        <span>x</span>
                        <input type="number" id="grid-size-y" class="grid-input" value="10" min="1" max="100" step="1">
                    </div>
                    <button id="toggle-grid" class="green-btn grid-btn">Включить сетку</button>
                </div>
            </div>
            
            <div class="sidebar-section">
                <h2>Масштаб</h2>
                <div class="zoom-controls-sidebar">
                    <div class="zoom-display-sidebar" id="zoom-level-sidebar">100%</div>
                    <button class="zoom-btn-sidebar" id="zoom-in-sidebar">+</button>
                    <button class="zoom-btn-sidebar" id="zoom-out-sidebar">-</button>
                    <button class="zoom-btn-sidebar" id="reset-view-sidebar">Сброс</button>
                </div>
            </div>
            
            <div class="sidebar-section">
                <h2>Управление проектом</h2>
                <button id="save-project" class="green-btn">Сохранить проект</button>
                <button id="load-project" class="green-btn">Загрузить проект</button>
                <button id="clear-all" class="red-btn">Очистить всё</button>
                <button id="export-btn" class="green-btn">Экспорт в PNG</button>
                <div class="status-indicator status-active" id="save-status">Сохранено</div>
            </div>
        </div>
        
        <div class="canvas-area">
            <div class="canvas-container" id="canvas-container">
                <div id="canvas">
                    <canvas id="grid-layer" class="grid-layer"></canvas>
                    <div class="connectors-layer" id="connectors-layer"></div>
                    <div class="blocks-layer" id="blocks-layer"></div>
                </div>
            </div>
            
            <div class="edit-panel" id="edit-panel">
                <div class="edit-panel-header">
                    Редактирование блока
                    <button style="
                        width: 30px; 
                        height: 30px; 
                        border: 2px solid #cc0000; 
                        background: #ff4444; 
                        border-radius: 4px; 
                        cursor: pointer;
                        font-size: 18px;
                        color: white;
                        font-weight: bold;
                        position: absolute;
                        top: -10px;
                        right: -10px;
                        margin: 0;
                        padding: 0;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    " onclick="document.getElementById('edit-panel').style.display = 'none'; selectedBlock = null;">×</button>
                </div>
                <input type="text" id="edit-title" placeholder="Заголовок блока">
                <textarea id="edit-content" placeholder="Содержимое блока"></textarea>
                
                <div class="style-controls">
                    <h3>Стиль блока</h3>
                    
                    <div class="color-controls">
                        <label>Цвет обводки:</label>
                        <input type="color" id="edit-border-color" class="color-input" value="#27ae60">
                    </div>
                    
                    <div class="border-width-controls">
                        <label>Ширина обводки:</label>
                        <input type="number" id="edit-border-width" class="border-width-input" value="2" min="1" max="10">
                        <span>px</span>
                    </div>
                    
                    <div class="color-controls">
                        <label>Цвет фона:</label>
                        <input type="color" id="edit-background-color" class="color-input" value="#ffffff">
                    </div>
                    
                    <label>Шрифт:</label>
                    <select id="edit-font-family">
                        <option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Segoe UI</option>
                        <option value="'Roboto', sans-serif">Roboto</option>
                        <option value="'Open Sans', sans-serif">Open Sans</option>
                        <option value="'Montserrat', sans-serif">Montserrat</option>
                        <option value="'Lato', sans-serif">Lato</option>
                        <option value="'Source Sans Pro', sans-serif">Source Sans Pro</option>
                        <option value="'Oswald', sans-serif">Oswald</option>
                        <option value="'Raleway', sans-serif">Raleway</option>
                        <option value="'PT Sans', sans-serif">PT Sans</option>
                        <option value="'Merriweather', serif">Merriweather</option>
                        <option value="'Playfair Display', serif">Playfair Display</option>
                        <option value="'Roboto Slab', serif">Roboto Slab</option>
                        <option value="'Noto Sans', sans-serif">Noto Sans</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="'Courier New', monospace">Courier New</option>
                    </select>
                    
                    <div class="style-section">
                        <h4>Стиль заголовка</h4>
                        <div class="color-controls">
                            <label>Цвет текста:</label>
                            <input type="color" id="edit-header-color" class="color-input" value="#27ae60">
                        </div>
                        
                        <label>Стиль текста:</label>
                        <div class="font-controls">
                            <button id="edit-header-bold" class="font-btn">Жирный</button>
                            <button id="edit-header-italic" class="font-btn">Курсив</button>
                            <button id="edit-header-underline" class="font-btn">Подчеркнутый</button>
                        </div>
                        
                        <div class="divider-controls">
                            <label>Разделительная линия:</label>
                            <input type="checkbox" id="edit-header-divider" class="divider-checkbox" checked>
                        </div>
                        
                        <div class="color-controls">
                            <label>Цвет линии:</label>
                            <input type="color" id="edit-divider-color" class="color-input" value="#eeeeee">
                        </div>
                    </div>
                    
                    <div class="style-section">
                        <h4>Стиль содержимого</h4>
                        <div class="color-controls">
                            <label>Цвет текста:</label>
                            <input type="color" id="edit-content-color" class="color-input" value="#000000">
                        </div>
                        
                        <label>Стиль текста:</label>
                        <div class="font-controls">
                            <button id="edit-content-bold" class="font-btn">Жирный</button>
                            <button id="edit-content-italic" class="font-btn">Курсив</button>
                            <button id="edit-content-underline" class="font-btn">Подчеркнутый</button>
                        </div>
                    </div>
                </div>
                
                <div class="media-type-selector">
                    <button id="edit-image-btn" class="media-type-btn active">Изображение</button>
                    <button id="edit-video-btn" class="media-type-btn">Видео</button>
                </div>
                
                <div class="image-size-controls" id="image-size-controls">
                    <label>Размер изображения:</label>
                    <input type="number" id="edit-image-width" class="image-size-input" placeholder="Ширина (px)" min="1" max="300">
                    <input type="number" id="edit-image-height" class="image-size-input" placeholder="Высота (px)" min="1" max="150">
                </div>
                
                <div class="video-size-controls" id="video-size-controls">
                    <label>Размер видео:</label>
                    <input type="number" id="edit-video-width" class="video-size-input" placeholder="Ширина (px)" min="1" max="300">
                    <input type="number" id="edit-video-height" class="video-size-input" placeholder="Высота (px)" min="1" max="150">
                </div>
                
                <input type="file" id="edit-image-input" class="file-input" accept="image/*">
                <input type="file" id="edit-video-input" class="file-input" accept="video/*">
                
                <button id="remove-media-btn" class="red-btn">Удалить медиа</button>
                <button id="save-edit" class="green-btn">Сохранить</button>
                <button id="delete-block" class="red-btn">Удалить блок</button>
                <button id="cancel-edit" class="green-btn">Отмена</button>
            </div>
            
            <div class="context-menu" id="context-menu">
                <div class="context-menu-item" id="context-edit">Редактировать</div>
                <div class="context-menu-item" id="context-delete">Удалить</div>
            </div>
            
            <input type="file" id="file-input" class="file-input" accept=".json">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('canvas');
            const gridLayer = document.getElementById('grid-layer');
            const gridCtx = gridLayer.getContext('2d');
            const blocksLayer = document.getElementById('blocks-layer');
            const connectorsLayer = document.getElementById('connectors-layer');
            const canvasContainer = document.getElementById('canvas-container');
            const blockTitleInput = document.getElementById('block-title');
            const blockContentInput = document.getElementById('block-content');
            const addBlockBtn = document.getElementById('add-block');
            const uploadImageBtn = document.getElementById('upload-image-btn');
            const uploadVideoBtn = document.getElementById('upload-video-btn');
            const imageInput = document.getElementById('image-input');
            const videoInput = document.getElementById('video-input');
            const modeSelectors = document.querySelectorAll('.mode-selector');
            const saveProjectBtn = document.getElementById('save-project');
            const loadProjectBtn = document.getElementById('load-project');
            const clearAllBtn = document.getElementById('clear-all');
            const exportBtn = document.getElementById('export-btn');
            const saveStatus = document.getElementById('save-status');
            const editPanel = document.getElementById('edit-panel');
            const editTitleInput = document.getElementById('edit-title');
            const editContentInput = document.getElementById('edit-content');
            const editImageBtn = document.getElementById('edit-image-btn');
            const editVideoBtn = document.getElementById('edit-video-btn');
            const editImageInput = document.getElementById('edit-image-input');
            const editVideoInput = document.getElementById('edit-video-input');
            const removeMediaBtn = document.getElementById('remove-media-btn');
            const saveEditBtn = document.getElementById('save-edit');
            const deleteBlockBtn = document.getElementById('delete-block');
            const cancelEditBtn = document.getElementById('cancel-edit');
            const imageSizeControls = document.getElementById('image-size-controls');
            const videoSizeControls = document.getElementById('video-size-controls');
            const editImageWidth = document.getElementById('edit-image-width');
            const editImageHeight = document.getElementById('edit-image-height');
            const editVideoWidth = document.getElementById('edit-video-width');
            const editVideoHeight = document.getElementById('edit-video-height');
            const fileInput = document.getElementById('file-input');
            const zoomInBtnSidebar = document.getElementById('zoom-in-sidebar');
            const zoomOutBtnSidebar = document.getElementById('zoom-out-sidebar');
            const resetViewBtnSidebar = document.getElementById('reset-view-sidebar');
            const zoomLevelDisplaySidebar = document.getElementById('zoom-level-sidebar');
            const helpBtn = document.getElementById('help-btn');
            const helpPanel = document.getElementById('help-panel');
            const closeHelpBtn = document.getElementById('close-help');
            const gridSizeXInput = document.getElementById('grid-size-x');
            const gridSizeYInput = document.getElementById('grid-size-y');
            const toggleGridBtn = document.getElementById('toggle-grid');
            const toggleSidebarBtn = document.getElementById('toggle-sidebar');
            const sidebar = document.getElementById('sidebar');
            const addBlockSection = document.getElementById('add-block-section');
            const connectorStyleSelector = document.getElementById('connector-style-selector');
            const connectorStyleBtns = document.querySelectorAll('.connector-style-btn');
            const themeControls = document.getElementById('theme-controls');
            const themeBtns = document.querySelectorAll('.theme-btn');
            const contextMenu = document.getElementById('context-menu');
            const contextEdit = document.getElementById('context-edit');
            const contextDelete = document.getElementById('context-delete');
            
            const editBorderColor = document.getElementById('edit-border-color');
            const editBorderWidth = document.getElementById('edit-border-width');
            const editBackgroundColor = document.getElementById('edit-background-color');
            const editFontFamily = document.getElementById('edit-font-family');
            
            const editHeaderColor = document.getElementById('edit-header-color');
            const editHeaderBoldBtn = document.getElementById('edit-header-bold');
            const editHeaderItalicBtn = document.getElementById('edit-header-italic');
            const editHeaderUnderlineBtn = document.getElementById('edit-header-underline');
            const editHeaderDivider = document.getElementById('edit-header-divider');
            const editDividerColor = document.getElementById('edit-divider-color');
            
            const editContentColor = document.getElementById('edit-content-color');
            const editContentBoldBtn = document.getElementById('edit-content-bold');
            const editContentItalicBtn = document.getElementById('edit-content-italic');
            const editContentUnderlineBtn = document.getElementById('edit-content-underline');
            
            // Элементы для настроек соединений
            const connectorSettings = document.querySelectorAll('.connector-settings');
            const straightWidth = document.getElementById('straight-width');
            const arrowWidth = document.getElementById('arrow-width');
            const arrowSize = document.getElementById('arrow-size');
            const zigzagWidth = document.getElementById('zigzag-width');
            const zigzagHeight = document.getElementById('zigzag-height');
            const zigzagSegments = document.getElementById('zigzag-segments');
            const waveWidth = document.getElementById('wave-width');
            const waveHeight = document.getElementById('wave-height');
            const waveCount = document.getElementById('wave-count');
            const arcWidth = document.getElementById('arc-width');
            const arcHeight = document.getElementById('arc-height');
            const loopWidth = document.getElementById('loop-width');
            const loopHeight = document.getElementById('loop-height');
            
            let blocks = [];
            let connections = [];
            let currentMode = 'move';
            let isDragging = false;
            let dragBlock = null;
            let startX, startY, initialLeft, initialTop;
            let connectStartBlock = null;
            let tempConnector = null;
            let selectedBlock = null;
            let nextBlockId = 1;
            let nextConnectionId = 1;
            let isSaved = true;
            let canvasScale = 1;
            let isCanvasDragging = false;
            let canvasStartX, canvasStartY, canvasScrollLeft, canvasScrollTop;
            let isHelpOpen = false;
            let hoveredBlock = null;
            let gridEnabled = false;
            let gridSizeX = 10;
            let gridSizeY = 10;
            let isEditPanelDragging = false;
            let editPanelStartX, editPanelStartY, editPanelInitialLeft, editPanelInitialTop;
            let connectorStyle = 'straight';
            let currentTheme = 'light';
            
            let isHeaderBold = false;
            let isHeaderItalic = false;
            let isHeaderUnderline = false;
            let isContentBold = false;
            let isContentItalic = false;
            let isContentUnderline = false;
            let showHeaderDivider = true;
            
            let currentMediaType = 'image';
            let currentEditMediaType = 'image';
            
            // Параметры для каждого типа соединения
            const connectorParams = {
                straight: { width: 3 },
                arrow: { width: 3, size: 10 },
                zigzag: { width: 3, height: 20, segments: 8 },
                wave: { width: 3, height: 30, count: 6 },
                arc: { width: 3, height: 50 },
                loop: { width: 3, height: 80 }
            };
            
            // Инициализация видимости секций
            updateSectionVisibility();
            
            // Переключение боковой панели на мобильных устройствах
            toggleSidebarBtn.addEventListener('click', function() {
                sidebar.classList.toggle('open');
            });
            
            // Обработчики для контекстного меню
            contextEdit.addEventListener('click', function() {
                if (selectedBlock) {
                    openEditPanel(selectedBlock);
                    contextMenu.style.display = 'none';
                }
            });
            
            contextDelete.addEventListener('click', function() {
                if (selectedBlock) {
                    selectedBlock.element.remove();
                    
                    const connectionsToRemove = connections.filter(conn => 
                        conn.from === selectedBlock.id || conn.to === selectedBlock.id
                    );
                    
                    connectionsToRemove.forEach(conn => {
                        conn.element.remove();
                        const index = connections.indexOf(conn);
                        if (index !== -1) connections.splice(index, 1);
                    });
                    
                    const index = blocks.indexOf(selectedBlock);
                    if (index !== -1) blocks.splice(index, 1);
                    
                    contextMenu.style.display = 'none';
                    selectedBlock = null;
                    
                    setUnsavedState();
                }
            });
            
            // Закрытие контекстного меню при клике вне его
            document.addEventListener('click', function(e) {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.style.display = 'none';
                }
            });
            
            function resizeGridCanvas() {
                gridLayer.width = canvas.offsetWidth;
                gridLayer.height = canvas.offsetHeight;
                drawGrid();
            }
            window.addEventListener('resize', resizeGridCanvas);
            resizeGridCanvas();
            
            // Обработчики для выбора стиля соединений
            connectorStyleBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    connectorStyleBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    connectorStyle = this.dataset.style;
                    
                    // Показываем настройки для выбранного стиля
                    connectorSettings.forEach(setting => setting.classList.remove('show'));
                    document.getElementById(`${connectorStyle}-settings`).classList.add('show');
                    
                    updateConnections();
                });
            });
            
            // Обработчики для изменения параметров соединений
            straightWidth.addEventListener('input', function() {
                connectorParams.straight.width = parseInt(this.value);
                updateConnections();
            });
            
            arrowWidth.addEventListener('input', function() {
                connectorParams.arrow.width = parseInt(this.value);
                updateConnections();
            });
            
            arrowSize.addEventListener('input', function() {
                connectorParams.arrow.size = parseInt(this.value);
                updateConnections();
            });
            
            zigzagWidth.addEventListener('input', function() {
                connectorParams.zigzag.width = parseInt(this.value);
                updateConnections();
            });
            
            zigzagHeight.addEventListener('input', function() {
                connectorParams.zigzag.height = parseInt(this.value);
                updateConnections();
            });
            
            zigzagSegments.addEventListener('input', function() {
                connectorParams.zigzag.segments = parseInt(this.value);
                updateConnections();
            });
            
            waveWidth.addEventListener('input', function() {
                connectorParams.wave.width = parseInt(this.value);
                updateConnections();
            });
            
            waveHeight.addEventListener('input', function() {
                connectorParams.wave.height = parseInt(this.value);
                updateConnections();
            });
            
            waveCount.addEventListener('input', function() {
                connectorParams.wave.count = parseInt(this.value);
                updateConnections();
            });
            
            arcWidth.addEventListener('input', function() {
                connectorParams.arc.width = parseInt(this.value);
                updateConnections();
            });
            
            arcHeight.addEventListener('input', function() {
                connectorParams.arc.height = parseInt(this.value);
                updateConnections();
            });
            
            loopWidth.addEventListener('input', function() {
                connectorParams.loop.width = parseInt(this.value);
                updateConnections();
            });
            
            loopHeight.addEventListener('input', function() {
                connectorParams.loop.height = parseInt(this.value);
                updateConnections();
            });
            
            // Обработчики для выбора темы
            themeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    themeBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentTheme = this.dataset.theme;
                    document.body.classList.toggle('dark-theme', currentTheme === 'dark');
                    drawGrid();
                });
            });
            
            // Обработчики для переключения режимов
            modeSelectors.forEach(selector => {
                selector.addEventListener('click', function() {
                    modeSelectors.forEach(s => s.classList.remove('active'));
                    this.classList.add('active');
                    currentMode = this.dataset.mode;
                    
                    // Обновляем видимость секций
                    updateSectionVisibility();
                    
                    if (connectStartBlock) {
                        connectStartBlock.classList.remove('connecting');
                        connectStartBlock = null;
                    }
                    
                    if (tempConnector) {
                        tempConnector.remove();
                        tempConnector = null;
                    }
                    
                    if (hoveredBlock) {
                        hoveredBlock.classList.remove('connecting');
                        hoveredBlock = null;
                    }
                    
                    canvasContainer.removeEventListener('mousemove', updateTempConnector);
                    canvasContainer.removeEventListener('touchmove', updateTempConnector);
                });
            });
            
            // Функция для обновления видимости секций
            function updateSectionVisibility() {
                // Скрываем все секции, зависящие от режима
                addBlockSection.style.display = 'none';
                connectorStyleSelector.style.display = 'none';
                themeControls.style.display = 'none';
                
                // Показываем секции в зависимости от текущего режима
                if (currentMode === 'move') {
                    addBlockSection.style.display = 'block';
                } else if (currentMode === 'connect') {
                    connectorStyleSelector.style.display = 'block';
                }
            }
            
            function setupVideoControls(block) {
                const videoWrapper = block.querySelector('.block-video-wrapper');
                const video = block.querySelector('video');
                const playPauseBtn = block.querySelector('.play-pause');
                const muteBtn = block.querySelector('.mute');
                const fullscreenBtn = block.querySelector('.fullscreen');
                
                if (!video) return;
                
                video.controls = false;
                video.style.background = 'transparent';
                
                if (playPauseBtn) {
                    playPauseBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        if (video.paused) {
                            video.play();
                            playPauseBtn.textContent = '⏸️';
                        } else {
                            video.pause();
                            playPauseBtn.textContent = '▶️';
                        }
                    });
                    
                    video.addEventListener('play', function() {
                        playPauseBtn.textContent = '⏸️';
                    });
                    
                    video.addEventListener('pause', function() {
                        playPauseBtn.textContent = '▶️';
                    });
                }
                
                if (muteBtn) {
                    muteBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        video.muted = !video.muted;
                        muteBtn.textContent = video.muted ? '🔇' : '🔊';
                    });
                    
                    video.addEventListener('volumechange', function() {
                        muteBtn.textContent = video.muted ? '🔇' : '🔊';
                    });
                }
                
                if (fullscreenBtn) {
                    fullscreenBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        if (video.requestFullscreen) {
                            video.requestFullscreen();
                        } else if (video.webkitRequestFullscreen) {
                            video.webkitRequestFullscreen();
                        } else if (video.msRequestFullscreen) {
                            video.msRequestFullscreen();
                        }
                    });
                }
                
                video.addEventListener('click', function(e) {
                    e.stopPropagation();
                    if (video.paused) {
                        video.play();
                    } else {
                        video.pause();
                    }
                });
                
                if (videoWrapper) {
                    videoWrapper.addEventListener('click', function(e) {
                        e.stopPropagation();
                    });
                }
            }
            
            uploadImageBtn.addEventListener('click', function() {
                currentMediaType = 'image';
                uploadImageBtn.classList.add('active');
                uploadVideoBtn.classList.remove('active');
                imageInput.click();
            });
            
            uploadVideoBtn.addEventListener('click', function() {
                currentMediaType = 'video';
                uploadVideoBtn.classList.add('active');
                uploadImageBtn.classList.remove('active');
                videoInput.click();
            });
            
            editImageBtn.addEventListener('click', function() {
                currentEditMediaType = 'image';
                editImageBtn.classList.add('active');
                editVideoBtn.classList.remove('active');
                imageSizeControls.classList.add('show');
                videoSizeControls.classList.remove('show');
                editImageInput.click();
            });
            
            editVideoBtn.addEventListener('click', function() {
                currentEditMediaType = 'video';
                editVideoBtn.classList.add('active');
                editImageBtn.classList.remove('active');
                videoSizeControls.classList.add('show');
                imageSizeControls.classList.remove('show');
                editVideoInput.click();
            });
            
            editHeaderBoldBtn.addEventListener('click', function() {
                isHeaderBold = !isHeaderBold;
                this.classList.toggle('active', isHeaderBold);
            });
            
            editHeaderItalicBtn.addEventListener('click', function() {
                isHeaderItalic = !isHeaderItalic;
                this.classList.toggle('active', isHeaderItalic);
            });
            
            editHeaderUnderlineBtn.addEventListener('click', function() {
                isHeaderUnderline = !isHeaderUnderline;
                this.classList.toggle('active', isHeaderUnderline);
            });
            
            editHeaderDivider.addEventListener('change', function() {
                showHeaderDivider = this.checked;
            });
            
            editContentBoldBtn.addEventListener('click', function() {
                isContentBold = !isContentBold;
                this.classList.toggle('active', isContentBold);
            });
            
            editContentItalicBtn.addEventListener('click', function() {
                isContentItalic = !isContentItalic;
                this.classList.toggle('active', isContentItalic);
            });
            
            editContentUnderlineBtn.addEventListener('click', function() {
                isContentUnderline = !isContentUnderline;
                this.classList.toggle('active', isContentUnderline);
            });
            
            helpBtn.addEventListener('click', function() {
                isHelpOpen = !isHelpOpen;
                helpPanel.style.display = isHelpOpen ? 'block' : 'none';
            });
            
            closeHelpBtn.addEventListener('click', function() {
                isHelpOpen = false;
                helpPanel.style.display = 'none';
            });
            
            const editPanelHeader = editPanel.querySelector('.edit-panel-header');
            
            editPanelHeader.addEventListener('mousedown', startEditPanelDrag);
            editPanelHeader.addEventListener('touchstart', startEditPanelDrag, { passive: false });
            
            function startEditPanelDrag(e) {
                if (e.target.style.background === '#ff4444') return;
                
                isEditPanelDragging = true;
                const touch = e.type === 'touchstart' ? e.touches[0] : e;
                editPanelStartX = touch.clientX;
                editPanelStartY = touch.clientY;
                
                const computedStyle = getComputedStyle(editPanel);
                editPanelInitialLeft = parseInt(computedStyle.left) || 0;
                editPanelInitialTop = parseInt(computedStyle.top) || 0;
                
                e.preventDefault();
                
                document.addEventListener('mousemove', dragEditPanel);
                document.addEventListener('touchmove', dragEditPanel, { passive: false });
                document.addEventListener('mouseup', stopEditPanelDrag);
                document.addEventListener('touchend', stopEditPanelDrag);
            }
            
            function dragEditPanel(e) {
                if (!isEditPanelDragging) return;
                
                const touch = e.type === 'touchmove' ? e.touches[0] : e;
                const dx = touch.clientX - editPanelStartX;
                const dy = touch.clientY - editPanelStartY;
                
                let newLeft = editPanelInitialLeft + dx;
                let newTop = editPanelInitialTop + dy;
                
                const maxLeft = window.innerWidth - editPanel.offsetWidth;
                const maxTop = window.innerHeight - editPanel.offsetHeight;
                
                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));
                
                editPanel.style.left = newLeft + 'px';
                editPanel.style.top = newTop + 'px';
            }
            
            function stopEditPanelDrag() {
                isEditPanelDragging = false;
                document.removeEventListener('mousemove', dragEditPanel);
                document.removeEventListener('touchmove', dragEditPanel);
                document.removeEventListener('mouseup', stopEditPanelDrag);
                document.removeEventListener('touchend', stopEditPanelDrag);
            }
            
            imageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        createMediaBlock(e.target.result, 'image');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            videoInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        createMediaBlock(e.target.result, 'video');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            function createMediaBlock(mediaData, mediaType) {
                const blockId = nextBlockId++;
                const block = document.createElement('div');
                block.className = `block ${mediaType}-only`;
                block.id = `block-${blockId}`;
                
                let initialX = 100;
                let initialY = 100;
                
                if (gridEnabled) {
                    initialX = snapToGrid(initialX, gridSizeX);
                    initialY = snapToGrid(initialY, gridSizeY);
                }
                
                block.style.left = initialX + 'px';
                block.style.top = initialY + 'px';
                
                if (mediaType === 'image') {
                    block.innerHTML = `
                        <img class="block-image-only" src="${mediaData}">
                    `;
                } else if (mediaType === 'video') {
                    block.innerHTML = `
                        <div class="block-video-wrapper">
                            <video class="block-video-only" preload="metadata">
                                <source src="${mediaData}" type="video/mp4">
                                Ваш браузер не поддерживает видео.
                            </video>
                            <div class="video-controls">
                                <button class="video-control-btn play-pause">▶️</button>
                                <button class="video-control-btn mute">🔊</button>
                                <button class="video-control-btn fullscreen">⛶</button>
                            </div>
                        </div>
                    `;
                }
                
                blocksLayer.appendChild(block);
                
                const blockData = {
                    id: blockId,
                    element: block,
                    title: "",
                    content: "",
                    mediaType: mediaType,
                    media: mediaData,
                    mediaWidth: null,
                    mediaHeight: null,
                    borderColor: '#27ae60',
                    borderWidth: 2,
                    backgroundColor: '#ffffff',
                    fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
                    headerColor: '#27ae60',
                    headerFontWeight: 'normal',
                    headerFontStyle: 'normal',
                    headerTextDecoration: 'none',
                    showHeaderDivider: true,
                    dividerColor: '#eeeeee',
                    contentColor: '#000000',
                    contentFontWeight: 'normal',
                    contentFontStyle: 'normal',
                    contentTextDecoration: 'none'
                };
                
                blocks.push(blockData);
                
                if (mediaType === 'video') {
                    setTimeout(() => {
                        setupVideoControls(block);
                    }, 100);
                }
                
                setTimeout(() => {
                    updateBlockSize(block);
                    addBlockEventListeners(block, blockId);
                    setUnsavedState();
                    showNotification(`${mediaType === 'image' ? 'Изображение' : 'Видео'} добавлено`);
                }, 100);
            }
            
            editImageInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file && selectedBlock) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        updateBlockMedia(e.target.result, 'image');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            editVideoInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file && selectedBlock) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        updateBlockMedia(e.target.result, 'video');
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            function updateBlockMedia(mediaData, mediaType) {
                if (!selectedBlock) return;
                
                selectedBlock.mediaType = mediaType;
                selectedBlock.media = mediaData;
                selectedBlock.mediaWidth = null;
                selectedBlock.mediaHeight = null;
                
                let mediaElement = selectedBlock.element.querySelector('.block-image, .block-image-only, .block-video, .block-video-only');
                let mediaWrapper = selectedBlock.element.querySelector('.block-video-wrapper');
                
                if (mediaElement) mediaElement.remove();
                if (mediaWrapper) mediaWrapper.remove();
                
                if (mediaType === 'image') {
                    mediaElement = document.createElement('img');
                    mediaElement.className = selectedBlock.title || selectedBlock.content ? 'block-image' : 'block-image-only';
                    selectedBlock.element.appendChild(mediaElement);
                    if (!selectedBlock.title && !selectedBlock.content) {
                        selectedBlock.element.classList.add('image-only');
                        selectedBlock.element.classList.remove('video-only');
                    }
                } else if (mediaType === 'video') {
                    mediaWrapper = document.createElement('div');
                    mediaWrapper.className = 'block-video-wrapper';
                    mediaWrapper.innerHTML = `
                        <video class="${selectedBlock.title || selectedBlock.content ? 'block-video' : 'block-video-only'}" preload="metadata">
                            <source src="${mediaData}" type="video/mp4">
                            Ваш браузер не поддерживает видео.
                        </video>
                        <div class="video-controls">
                            <button class="video-control-btn play-pause">▶️</button>
                            <button class="video-control-btn mute">🔊</button>
                            <button class="video-control-btn fullscreen">⛶</button>
                        </div>
                    `;
                    selectedBlock.element.appendChild(mediaWrapper);
                    if (!selectedBlock.title && !selectedBlock.content) {
                        selectedBlock.element.classList.add('video-only');
                        selectedBlock.element.classList.remove('image-only');
                    }
                    
                    setTimeout(() => {
                        setupVideoControls(selectedBlock.element);
                    }, 100);
                }
                
                if (mediaType === 'image') {
                    mediaElement.src = mediaData;
                    const img = new Image();
                    img.src = mediaData;
                    img.onload = function() {
                        updateBlockSize(selectedBlock.element);
                        setUnsavedState();
                        showNotification('Изображение обновлено');
                    };
                } else {
                    const video = mediaWrapper.querySelector('video');
                    video.src = mediaData;
                    video.onloadeddata = function() {
                        updateBlockSize(selectedBlock.element);
                        setUnsavedState();
                        showNotification('Видео обновлено');
                    };
                }
            }
            
            removeMediaBtn.addEventListener('click', function() {
                if (selectedBlock) {
                    selectedBlock.media = null;
                    selectedBlock.mediaType = null;
                    selectedBlock.mediaWidth = null;
                    selectedBlock.mediaHeight = null;
                    
                    const mediaElement = selectedBlock.element.querySelector('.block-image, .block-image-only, .block-video, .block-video-only');
                    const mediaWrapper = selectedBlock.element.querySelector('.block-video-wrapper');
                    
                    if (mediaElement) mediaElement.remove();
                    if (mediaWrapper) mediaWrapper.remove();
                    
                    selectedBlock.element.classList.remove('image-only', 'video-only');
                    imageSizeControls.classList.remove('show');
                    videoSizeControls.classList.remove('show');
                    updateBlockSize(selectedBlock.element);
                    setUnsavedState();
                    showNotification('Медиа удалено');
                }
            });
            
            addBlockBtn.addEventListener('click', function() {
                const title = blockTitleInput.value.trim() || 'Новый блок';
                const content = blockContentInput.value.trim() || 'Содержимое блока';
                
                const blockId = nextBlockId++;
                const block = document.createElement('div');
                block.className = 'block';
                block.id = `block-${blockId}`;
                
                let initialX = 100;
                let initialY = 100;
                
                if (gridEnabled) {
                    initialX = snapToGrid(initialX, gridSizeX);
                    initialY = snapToGrid(initialY, gridSizeY);
                }
                
                block.style.left = initialX + 'px';
                block.style.top = initialY + 'px';
                block.innerHTML = `
                    <div class="block-header">${title}</div>
                    <div class="block-content">${content}</div>
                `;
                
                blocksLayer.appendChild(block);
                blocks.push({
                    id: blockId, 
                    element: block, 
                    title, 
                    content, 
                    mediaType: null,
                    media: null,
                    mediaWidth: null,
                    mediaHeight: null,
                    borderColor: '#27ae60',
                    borderWidth: 2,
                    backgroundColor: '#ffffff',
                    fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
                    headerColor: '#27ae60',
                    headerFontWeight: 'normal',
                    headerFontStyle: 'normal',
                    headerTextDecoration: 'none',
                    showHeaderDivider: true,
                    dividerColor: '#eeeeee',
                    contentColor: '#000000',
                    contentFontWeight: 'normal',
                    contentFontStyle: 'normal',
                    contentTextDecoration: 'none'
                });
                
                updateBlockSize(block);
                
                addBlockEventListeners(block, blockId);
                
                blockTitleInput.value = '';
                blockContentInput.value = '';
                
                setUnsavedState();
            });
            
            function drawGrid() {
                if (!gridEnabled) {
                    gridCtx.clearRect(0, 0, gridLayer.width, gridLayer.height);
                    return;
                }
                
                const gridColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(200, 200, 200, 0.3)';
                gridCtx.strokeStyle = gridColor;
                gridCtx.lineWidth = 1;
                
                const scaledGridSizeX = gridSizeX * canvasScale;
                const scaledGridSizeY = gridSizeY * canvasScale;
                const offsetX = (canvasContainer.scrollLeft % scaledGridSizeX) / canvasScale;
                const offsetY = (canvasContainer.scrollTop % scaledGridSizeY) / canvasScale;
                
                gridCtx.clearRect(0, 0, gridLayer.width, gridLayer.height);
                
                for (let x = offsetX; x < gridLayer.width / canvasScale; x += gridSizeX) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(x * canvasScale, 0);
                    gridCtx.lineTo(x * canvasScale, gridLayer.height);
                    gridCtx.stroke();
                }
                
                for (let y = offsetY; y < gridLayer.height / canvasScale; y += gridSizeY) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(0, y * canvasScale);
                    gridCtx.lineTo(gridLayer.width, y * canvasScale);
                    gridCtx.stroke();
                }
            }
            
            function updateBlockSizes() {
                blocks.forEach(block => updateBlockSize(block.element));
            }
            
            function updateBlockSize(block) {
                const header = block.querySelector('.block-header');
                const content = block.querySelector('.block-content');
                const image = block.querySelector('.block-image, .block-image-only');
                const video = block.querySelector('.block-video, .block-video-only');
                const isImageOnly = block.classList.contains('image-only');
                const isVideoOnly = block.classList.contains('video-only');
                const blockData = blocks.find(b => b.element === block);
                
                block.style.width = 'auto';
                block.style.height = 'auto';
                
                if ((isImageOnly && image && blockData) || (isVideoOnly && video && blockData)) {
                    const mediaElement = image || video;
                    const isVideo = !!video;
                    
                    if (isVideo) {
                        let mediaWidth = blockData.mediaWidth || 200;
                        let mediaHeight = blockData.mediaHeight || 150;
                        
                        const maxWidth = 300;
                        const maxHeight = 150;
                        const scale = Math.min(maxWidth / mediaWidth, maxHeight / mediaHeight, 1);
                        mediaWidth = mediaWidth * scale;
                        mediaHeight = mediaHeight * scale;
                        
                        block.style.width = mediaWidth + 'px';
                        block.style.height = mediaHeight + 'px';
                        
                        mediaElement.style.width = mediaWidth + 'px';
                        mediaElement.style.height = mediaHeight + 'px';
                    } else {
                        const img = new Image();
                        img.src = mediaElement.src;
                        img.onload = function() {
                            let mediaWidth = blockData.mediaWidth || img.naturalWidth;
                            let mediaHeight = blockData.mediaHeight || img.naturalHeight;
                            
                            const maxWidth = 300;
                            const maxHeight = 150;
                            const scale = Math.min(maxWidth / mediaWidth, maxHeight / mediaHeight, 1);
                            mediaWidth = mediaWidth * scale;
                            mediaHeight = mediaHeight * scale;
                            
                            block.style.width = mediaWidth + 'px';
                            block.style.height = mediaHeight + 'px';
                            
                            mediaElement.style.width = mediaWidth + 'px';
                            mediaElement.style.height = mediaHeight + 'px';
                            
                            updateConnections();
                        };
                    }
                } else {
                    let headerWidth = header ? header.scrollWidth : 0;
                    let contentWidth = content ? content.scrollWidth : 0;
                    let mediaWidth = 0;
                    
                    if (image || video) {
                        const mediaElement = image || video;
                        mediaWidth = blockData && blockData.mediaWidth ? blockData.mediaWidth : mediaElement.offsetWidth;
                    }
                    
                    const maxContentWidth = Math.min(Math.max(headerWidth, contentWidth, mediaWidth) + 30, 300);
                    block.style.width = maxContentWidth + 'px';
                    
                    let headerHeight = header ? header.offsetHeight : 0;
                    let contentHeight = content ? content.scrollHeight : 0;
                    let mediaHeight = 0;
                    
                    if (image || video) {
                        mediaHeight = blockData && blockData.mediaHeight ? blockData.mediaHeight : (image || video ? 160 : 0);
                    }
                    
                    const totalHeight = headerHeight + contentHeight + mediaHeight + 30;
                    block.style.height = totalHeight + 'px';
                    
                    if ((image || video) && blockData && blockData.mediaWidth && blockData.mediaHeight) {
                        const mediaElement = image || video;
                        mediaElement.style.width = blockData.mediaWidth + 'px';
                        mediaElement.style.height = blockData.mediaHeight + 'px';
                    }
                }
                
                updateConnections();
            }
            
            editContentInput.addEventListener('input', function() {
                if (selectedBlock) {
                    updateBlockSize(selectedBlock.element);
                }
            });
            
            editImageWidth.addEventListener('input', function() {
                if (selectedBlock && selectedBlock.mediaType === 'image') {
                    const width = parseInt(this.value);
                    if (width > 0 && width <= 300) {
                        selectedBlock.mediaWidth = width;
                        updateBlockSize(selectedBlock.element);
                        setUnsavedState();
                    }
                }
            });
            
            editImageHeight.addEventListener('input', function() {
                if (selectedBlock && selectedBlock.mediaType === 'image') {
                    const height = parseInt(this.value);
                    if (height > 0 && height <= 150) {
                        selectedBlock.mediaHeight = height;
                        updateBlockSize(selectedBlock.element);
                        setUnsavedState();
                    }
                }
            });
            
            editVideoWidth.addEventListener('input', function() {
                if (selectedBlock && selectedBlock.mediaType === 'video') {
                    const width = parseInt(this.value);
                    if (width > 0 && width <= 300) {
                        selectedBlock.mediaWidth = width;
                        updateBlockSize(selectedBlock.element);
                        setUnsavedState();
                    }
                }
            });
            
            editVideoHeight.addEventListener('input', function() {
                if (selectedBlock && selectedBlock.mediaType === 'video') {
                    const height = parseInt(this.value);
                    if (height > 0 && height <= 150) {
                        selectedBlock.mediaHeight = height;
                        updateBlockSize(selectedBlock.element);
                        setUnsavedState();
                    }
                }
            });
            
            blocks.forEach(block => {
                addBlockEventListeners(block.element, block.id);
            });
            
            function addBlockEventListeners(blockElement, blockId) {
                blockElement.addEventListener('click', handleBlockClick);
                blockElement.addEventListener('touchstart', handleBlockTouchStart, { passive: false });
                blockElement.addEventListener('mousedown', handleBlockMouseDown);
                blockElement.addEventListener('contextmenu', handleBlockContextMenu);
                blockElement.addEventListener('mouseenter', function() {
                    if (currentMode === 'connect' && connectStartBlock && blockElement !== connectStartBlock) {
                        hoveredBlock = blockElement;
                        blockElement.classList.add('connecting');
                    }
                });
                blockElement.addEventListener('mouseleave', function() {
                    if (hoveredBlock === blockElement) {
                        blockElement.classList.remove('connecting');
                        hoveredBlock = null;
                    }
                });
                
                function handleBlockClick(e) {
                    if (currentMode === 'connect') {
                        handleConnectModeClick(blockElement, blockId);
                    }
                    e.stopPropagation();
                }
                
                function handleBlockTouchStart(e) {
                    if (currentMode === 'move') {
                        startDragging(e, blockElement, blockId);
                    } else if (currentMode === 'connect') {
                        handleConnectModeClick(blockElement, blockId);
                    }
                    e.stopPropagation();
                }
                
                function handleBlockMouseDown(e) {
                    if (currentMode === 'move') {
                        startDragging(e, blockElement, blockId);
                    }
                    e.stopPropagation();
                }
                
                function handleBlockContextMenu(e) {
                    e.preventDefault();
                    const block = blocks.find(b => b.id === blockId);
                    if (block) {
                        selectedBlock = block;
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = e.pageX + 'px';
                        contextMenu.style.top = e.pageY + 'px';
                    }
                    return false;
                }
            }
            
            function handleConnectModeClick(blockElement, blockId) {
                if (!connectStartBlock) {
                    connectStartBlock = blockElement;
                    blockElement.classList.add('connecting');
                    
                    tempConnector = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    tempConnector.className = 'temp-connector';
                    tempConnector.style.position = 'absolute';
                    tempConnector.style.pointerEvents = 'none';
                    tempConnector.style.zIndex = '5';
                    
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.className = 'temp-connector-path';
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', '#e74c3c');
                    path.setAttribute('stroke-width', '3');
                    tempConnector.appendChild(path);
                    
                    connectorsLayer.appendChild(tempConnector);
                    
                    canvasContainer.addEventListener('mousemove', updateTempConnector);
                    canvasContainer.addEventListener('touchmove', updateTempConnector, { passive: false });
                    
                    document.addEventListener('click', cancelConnection, { once: true });
                    document.addEventListener('touchend', cancelConnection, { once: true });
                } else {
                    const startBlockId = parseInt(connectStartBlock.id.split('-')[1]);
                    
                    if (startBlockId !== blockId) {
                        const existingConnectionIndex = connections.findIndex(conn => 
                            (conn.from === startBlockId && conn.to === blockId) || 
                            (conn.from === blockId && conn.to === startBlockId)
                        );
                        
                        if (existingConnectionIndex !== -1) {
                            const connection = connections[existingConnectionIndex];
                            connection.element.remove();
                            connections.splice(existingConnectionIndex, 1);
                        } else {
                            createConnection(startBlockId, blockId);
                        }
                        
                        setUnsavedState();
                    }
                    
                    connectStartBlock.classList.remove('connecting');
                    connectStartBlock = null;
                    
                    if (tempConnector) {
                        tempConnector.remove();
                        tempConnector = null;
                    }
                    
                    if (hoveredBlock) {
                        hoveredBlock.classList.remove('connecting');
                        hoveredBlock = null;
                    }
                    
                    canvasContainer.removeEventListener('mousemove', updateTempConnector);
                    canvasContainer.removeEventListener('touchmove', updateTempConnector);
                }
            }
            
            function updateTempConnector(e) {
                if (!connectStartBlock || !tempConnector) return;
                
                e.preventDefault();
                
                const touch = e.type === 'touchmove' ? e.touches[0] : e;
                const containerRect = canvasContainer.getBoundingClientRect();
                const fromRect = connectStartBlock.getBoundingClientRect();
                
                const fromX = (parseInt(connectStartBlock.style.left) + connectStartBlock.offsetWidth / 2);
                const fromY = (parseInt(connectStartBlock.style.top) + connectStartBlock.offsetHeight / 2);
                
                const toX = (touch.clientX - containerRect.left + canvasContainer.scrollLeft) / canvasScale;
                const toY = (touch.clientY - containerRect.top + canvasContainer.scrollTop) / canvasScale;
                
                drawConnector(tempConnector, fromX, fromY, toX, toY, connectorStyle, true);
            }
            
            function cancelConnection(e) {
                if (!connectStartBlock) return;
                
                const target = e.type === 'touchend' ? document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY) : e.target;
                if (!target.classList.contains('block')) {
                    connectStartBlock.classList.remove('connecting');
                    connectStartBlock = null;
                    
                    if (tempConnector) {
                        tempConnector.remove();
                        tempConnector = null;
                    }
                    
                    if (hoveredBlock) {
                        hoveredBlock.classList.remove('connecting');
                        hoveredBlock = null;
                    }
                    
                    canvasContainer.removeEventListener('mousemove', updateTempConnector);
                    canvasContainer.removeEventListener('touchmove', updateTempConnector);
                }
            }
            
            function openEditPanel(block) {
                selectedBlock = block;
                
                editTitleInput.value = block.title;
                editContentInput.value = block.content;
                
                if (block.mediaType === 'image') {
                    editImageWidth.value = block.mediaWidth || '';
                    editImageHeight.value = block.mediaHeight || '';
                    imageSizeControls.classList.add('show');
                    videoSizeControls.classList.remove('show');
                    currentEditMediaType = 'image';
                    editImageBtn.classList.add('active');
                    editVideoBtn.classList.remove('active');
                } else if (block.mediaType === 'video') {
                    editVideoWidth.value = block.mediaWidth || '';
                    editVideoHeight.value = block.mediaHeight || '';
                    videoSizeControls.classList.add('show');
                    imageSizeControls.classList.remove('show');
                    currentEditMediaType = 'video';
                    editVideoBtn.classList.add('active');
                    editImageBtn.classList.remove('active');
                } else {
                    imageSizeControls.classList.remove('show');
                    videoSizeControls.classList.remove('show');
                }
                
                editBorderColor.value = block.borderColor;
                editBorderWidth.value = block.borderWidth;
                editBackgroundColor.value = block.backgroundColor;
                editFontFamily.value = block.fontFamily;
                
                editHeaderColor.value = block.headerColor;
                isHeaderBold = block.headerFontWeight === 'bold';
                isHeaderItalic = block.headerFontStyle === 'italic';
                isHeaderUnderline = block.headerTextDecoration === 'underline';
                showHeaderDivider = block.showHeaderDivider;
                
                editHeaderBoldBtn.classList.toggle('active', isHeaderBold);
                editHeaderItalicBtn.classList.toggle('active', isHeaderItalic);
                editHeaderUnderlineBtn.classList.toggle('active', isHeaderUnderline);
                editHeaderDivider.checked = showHeaderDivider;
                editDividerColor.value = block.dividerColor;
                
                editContentColor.value = block.contentColor;
                isContentBold = block.contentFontWeight === 'bold';
                isContentItalic = block.contentFontStyle === 'italic';
                isContentUnderline = block.contentTextDecoration === 'underline';
                
                editContentBoldBtn.classList.toggle('active', isContentBold);
                editContentItalicBtn.classList.toggle('active', isContentItalic);
                editContentUnderlineBtn.classList.toggle('active', isContentUnderline);
                
                const hasBeenMoved = editPanel.style.left && editPanel.style.top && 
                                    (editPanel.style.left !== '0px' || editPanel.style.top !== '0px');
                
                if (!hasBeenMoved) {
                    const rect = block.element.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();
                    
                    editPanel.style.left = (rect.right - containerRect.left + canvasContainer.scrollLeft + 10) + 'px';
                    editPanel.style.top = (rect.top - containerRect.top + canvasContainer.scrollTop) + 'px';
                }
                
                editPanel.style.display = 'block';
            }
            
            function startDragging(e, blockElement, blockId) {
                isDragging = true;
                dragBlock = blockElement;
                
                const touch = e.type === 'touchstart' ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;
                
                const computedStyle = getComputedStyle(blockElement);
                initialLeft = parseInt(computedStyle.left);
                initialTop = parseInt(computedStyle.top);
                
                e.preventDefault();
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('mouseup', stopDragging);
                document.addEventListener('touchend', stopDragging);
            }
            
            function drag(e) {
                if (!isDragging || !dragBlock) return;
                
                e.preventDefault();
                
                const touch = e.type === 'touchmove' ? e.touches[0] : e;
                const dx = (touch.clientX - startX) / canvasScale;
                const dy = (touch.clientY - startY) / canvasScale;
                
                let newLeft = initialLeft + dx;
                let newTop = initialTop + dy;
                
                if (gridEnabled) {
                    newLeft = snapToGrid(newLeft, gridSizeX);
                    newTop = snapToGrid(newTop, gridSizeY);
                }
                
                dragBlock.style.left = newLeft + 'px';
                dragBlock.style.top = newTop + 'px';
                
                updateConnections();
                
                setUnsavedState();
            }
            
            function stopDragging() {
                isDragging = false;
                dragBlock = null;
                
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', stopDragging);
                document.removeEventListener('touchend', stopDragging);
            }
            
            function snapToGrid(value, gridSize) {
                return Math.round(value / gridSize) * gridSize;
            }
            
            toggleGridBtn.addEventListener('click', function() {
                gridEnabled = !gridEnabled;
                
                if (gridEnabled) {
                    toggleGridBtn.textContent = 'Выключить сетку';
                    toggleGridBtn.classList.add('active');
                    
                    gridSizeX = parseInt(gridSizeXInput.value) || 10;
                    gridSizeY = parseInt(gridSizeYInput.value) || 10;
                    
                    blocks.forEach(block => {
                        const left = parseInt(block.element.style.left);
                        const top = parseInt(block.element.style.top);
                        
                        block.element.style.left = snapToGrid(left, gridSizeX) + 'px';
                        block.element.style.top = snapToGrid(top, gridSizeY) + 'px';
                    });
                    
                    drawGrid();
                    updateConnections();
                    setUnsavedState();
                } else {
                    toggleGridBtn.textContent = 'Включить сетку';
                    toggleGridBtn.classList.remove('active');
                    drawGrid();
                }
            });
            
            gridSizeXInput.addEventListener('change', function() {
                gridSizeX = parseInt(this.value) || 10;
                if (gridEnabled) {
                    blocks.forEach(block => {
                        const left = parseInt(block.element.style.left);
                        block.element.style.left = snapToGrid(left, gridSizeX) + 'px';
                    });
                    drawGrid();
                    updateConnections();
                    setUnsavedState();
                }
            });
            
            gridSizeYInput.addEventListener('change', function() {
                gridSizeY = parseInt(this.value) || 10;
                if (gridEnabled) {
                    blocks.forEach(block => {
                        const top = parseInt(block.element.style.top);
                        block.element.style.top = snapToGrid(top, gridSizeY) + 'px';
                    });
                    drawGrid();
                    updateConnections();
                    setUnsavedState();
                }
            });
            
            function createConnection(fromBlockId, toBlockId) {
                const fromBlock = document.getElementById(`block-${fromBlockId}`);
                const toBlock = document.getElementById(`block-${toBlockId}`);
                
                if (!fromBlock || !toBlock) return;
                
                const connectionId = nextConnectionId++;
                const connector = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                connector.className = `connector ${connectorStyle}`;
                connector.id = `connector-${connectionId}`;
                connector.style.position = 'absolute';
                connector.style.pointerEvents = 'none';
                connector.style.zIndex = '5';
                connector.style.overflow = 'visible';
                
                connectorsLayer.appendChild(connector);
                
                const connection = {
                    id: connectionId,
                    from: fromBlockId,
                    to: toBlockId,
                    element: connector,
                    style: connectorStyle
                };
                
                connections.push(connection);
                updateConnection(connection);
            }
            
            function updateConnections() {
                connections.forEach(conn => updateConnection(conn));
            }
            
            function updateConnection(connection) {
                const fromBlock = document.getElementById(`block-${connection.from}`);
                const toBlock = document.getElementById(`block-${connection.to}`);
                
                if (!fromBlock || !toBlock) return;
                
                const fromX = parseInt(fromBlock.style.left) + fromBlock.offsetWidth / 2;
                const fromY = parseInt(fromBlock.style.top) + fromBlock.offsetHeight / 2;
                const toX = parseInt(toBlock.style.left) + toBlock.offsetWidth / 2;
                const toY = parseInt(toBlock.style.top) + toBlock.offsetHeight / 2;
                
                drawConnector(connection.element, fromX, fromY, toX, toY, connection.style);
            }
            
            function drawConnector(svgElement, fromX, fromY, toX, toY, style, isTemp = false) {
                // Очищаем SVG
                while (svgElement.firstChild) {
                    svgElement.removeChild(svgElement.firstChild);
                }
                
                const dx = toX - fromX;
                const dy = toY - fromY;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                // Вычисляем границы для SVG элемента
                const minX = Math.min(fromX, toX);
                const minY = Math.min(fromY, toY);
                const maxX = Math.max(fromX, toX);
                const maxY = Math.max(fromY, toY);
                
                // Устанавливаем размеры и позицию SVG
                const svgWidth = maxX - minX + 100; // Добавляем отступы
                const svgHeight = maxY - minY + 100;
                
                svgElement.style.width = svgWidth + 'px';
                svgElement.style.height = svgHeight + 'px';
                svgElement.style.left = (minX - 50) + 'px';
                svgElement.style.top = (minY - 50) + 'px';
                
                // Создаем путь в зависимости от стиля
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', isTemp ? '#e74c3c' : '#27ae60');
                
                // Получаем параметры для текущего стиля
                const params = connectorParams[style];
                
                // Устанавливаем толщину линии
                path.setAttribute('stroke-width', params.width);
                
                // Координаты относительно SVG элемента
                const relFromX = fromX - (minX - 50);
                const relFromY = fromY - (minY - 50);
                const relToX = toX - (minX - 50);
                const relToY = toY - (minY - 50);
                
                let pathData = '';
                
                switch(style) {
                    case 'straight':
                        pathData = `M ${relFromX} ${relFromY} L ${relToX} ${relToY}`;
                        break;
                    case 'arrow':
                        pathData = `M ${relFromX} ${relFromY} L ${relToX} ${relToY}`;
                        // Добавляем стрелку
                        const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                        const angle = Math.atan2(relToY - relFromY, relToX - relFromX);
                        const arrowSize = params.size;
                        const arrowX = relToX - arrowSize * Math.cos(angle);
                        const arrowY = relToY - arrowSize * Math.sin(angle);
                        
                        arrow.setAttribute('points', 
                            `${relToX},${relToY} ` +
                            `${arrowX + arrowSize * Math.cos(angle - Math.PI/6)},${arrowY + arrowSize * Math.sin(angle - Math.PI/6)} ` +
                            `${arrowX + arrowSize * Math.cos(angle + Math.PI/6)},${arrowY + arrowSize * Math.sin(angle + Math.PI/6)}`
                        );
                        arrow.setAttribute('fill', isTemp ? '#e74c3c' : '#27ae60');
                        arrow.classList.add('arrow-head');
                        svgElement.appendChild(arrow);
                        break;
                    case 'zigzag':
                        const segments = params.segments;
                        const stepX = (relToX - relFromX) / segments;
                        const stepY = (relToY - relFromY) / segments;
                        const zigzagHeight = params.height;
                        
                        pathData = `M ${relFromX} ${relFromY}`;
                        for (let i = 1; i <= segments; i++) {
                            const x = relFromX + i * stepX;
                            const y = relFromY + i * stepY;
                            if (i % 2 === 0) {
                                pathData += ` L ${x} ${y - zigzagHeight}`;
                            } else {
                                pathData += ` L ${x} ${y + zigzagHeight}`;
                            }
                        }
                        pathData += ` L ${relToX} ${relToY}`;
                        break;
                    case 'wave':
                        const waveSegments = params.count * 2;
                        const waveStepX = (relToX - relFromX) / waveSegments;
                        const waveStepY = (relToY - relFromY) / waveSegments;
                        const waveHeight = params.height;
                        
                        pathData = `M ${relFromX} ${relFromY}`;
                        for (let i = 1; i <= waveSegments; i++) {
                            const x = relFromX + i * waveStepX;
                            const y = relFromY + i * waveStepY;
                            const controlX1 = x - waveStepX/2;
                            const controlY1 = y + (i % 2 === 0 ? -waveHeight : waveHeight);
                            const controlX2 = x + waveStepX/2;
                            const controlY2 = y + (i % 2 === 0 ? -waveHeight : waveHeight);
                            pathData += ` C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${x} ${y}`;
                        }
                        break;
                    case 'arc':
                        const midX = (relFromX + relToX) / 2;
                        const midY = (relFromY + relToY) / 2 - params.height;
                        pathData = `M ${relFromX} ${relFromY} Q ${midX} ${midY} ${relToX} ${relToY}`;
                        break;
                    case 'loop':
                        const loopHeight = params.height;
                        const loopWidth = Math.abs(relToX - relFromX) / 2;
                        pathData = `M ${relFromX} ${relFromY} ` +
                                  `C ${relFromX + loopWidth} ${relFromY}, ${relToX - loopWidth} ${relToY - loopHeight}, ${relToX} ${relToY}`;
                        break;
                    default:
                        pathData = `M ${relFromX} ${relFromY} L ${relToX} ${relToY}`;
                }
                
                path.setAttribute('d', pathData);
                svgElement.appendChild(path);
            }
            
            saveEditBtn.addEventListener('click', function() {
                if (selectedBlock) {
                    selectedBlock.title = editTitleInput.value;
                    selectedBlock.content = editContentInput.value;
                    
                    if (selectedBlock.mediaType === 'image') {
                        selectedBlock.mediaWidth = parseInt(editImageWidth.value) || null;
                        selectedBlock.mediaHeight = parseInt(editImageHeight.value) || null;
                    } else if (selectedBlock.mediaType === 'video') {
                        selectedBlock.mediaWidth = parseInt(editVideoWidth.value) || null;
                        selectedBlock.mediaHeight = parseInt(editVideoHeight.value) || null;
                    }
                    
                    selectedBlock.borderColor = editBorderColor.value;
                    selectedBlock.borderWidth = parseInt(editBorderWidth.value) || 2;
                    selectedBlock.backgroundColor = editBackgroundColor.value;
                    selectedBlock.fontFamily = editFontFamily.value;
                    
                    selectedBlock.headerColor = editHeaderColor.value;
                    selectedBlock.headerFontWeight = isHeaderBold ? 'bold' : 'normal';
                    selectedBlock.headerFontStyle = isHeaderItalic ? 'italic' : 'normal';
                    selectedBlock.headerTextDecoration = isHeaderUnderline ? 'underline' : 'none';
                    selectedBlock.showHeaderDivider = showHeaderDivider;
                    selectedBlock.dividerColor = editDividerColor.value;
                    
                    selectedBlock.contentColor = editContentColor.value;
                    selectedBlock.contentFontWeight = isContentBold ? 'bold' : 'normal';
                    selectedBlock.contentFontStyle = isContentItalic ? 'italic' : 'normal';
                    selectedBlock.contentTextDecoration = isContentUnderline ? 'underline' : 'none';
                    
                    selectedBlock.element.style.borderColor = selectedBlock.borderColor;
                    selectedBlock.element.style.borderWidth = selectedBlock.borderWidth + 'px';
                    selectedBlock.element.style.borderStyle = 'solid';
                    selectedBlock.element.style.backgroundColor = selectedBlock.backgroundColor;
                    selectedBlock.element.style.fontFamily = selectedBlock.fontFamily;
                    
                    let headerElement = selectedBlock.element.querySelector('.block-header');
                    let contentElement = selectedBlock.element.querySelector('.block-content');
                    
                    if (selectedBlock.title || selectedBlock.content || !selectedBlock.media) {
                        if (!headerElement) {
                            headerElement = document.createElement('div');
                            headerElement.className = 'block-header';
                            selectedBlock.element.insertBefore(headerElement, selectedBlock.element.firstChild);
                        }
                        if (!contentElement) {
                            contentElement = document.createElement('div');
                            contentElement.className = 'block-content';
                            const mediaElement = selectedBlock.element.querySelector('.block-image, .block-image-only, .block-video-wrapper');
                            if (mediaElement) {
                                selectedBlock.element.insertBefore(contentElement, mediaElement);
                            } else {
                                selectedBlock.element.appendChild(contentElement);
                            }
                        }
                        selectedBlock.element.classList.remove('image-only', 'video-only');
                    } else {
                        if (headerElement) headerElement.remove();
                        if (contentElement) contentElement.remove();
                        if (selectedBlock.media) {
                            if (selectedBlock.mediaType === 'image') {
                                selectedBlock.element.classList.add('image-only');
                            } else if (selectedBlock.mediaType === 'video') {
                                selectedBlock.element.classList.add('video-only');
                            }
                        }
                    }
                    
                    if (headerElement) {
                        headerElement.textContent = selectedBlock.title;
                        headerElement.style.color = selectedBlock.headerColor;
                        headerElement.style.fontWeight = selectedBlock.headerFontWeight;
                        headerElement.style.fontStyle = selectedBlock.headerFontStyle;
                        headerElement.style.textDecoration = selectedBlock.headerTextDecoration;
                        
                        if (selectedBlock.showHeaderDivider) {
                            headerElement.style.borderBottom = `1px solid ${selectedBlock.dividerColor}`;
                            headerElement.style.paddingBottom = '5px';
                            headerElement.style.marginBottom = '8px';
                        } else {
                            headerElement.style.borderBottom = 'none';
                            headerElement.style.paddingBottom = '0';
                            headerElement.style.marginBottom = '0';
                        }
                    }
                    
                    if (contentElement) {
                        contentElement.textContent = selectedBlock.content;
                        contentElement.style.color = selectedBlock.contentColor;
                        contentElement.style.fontWeight = selectedBlock.contentFontWeight;
                        contentElement.style.fontStyle = selectedBlock.contentFontStyle;
                        contentElement.style.textDecoration = selectedBlock.contentTextDecoration;
                    }
                    
                    const imageElement = selectedBlock.element.querySelector('.block-image, .block-image-only');
                    const videoWrapper = selectedBlock.element.querySelector('.block-video-wrapper');
                    const videoElement = selectedBlock.element.querySelector('.block-video, .block-video-only');
                    
                    if (imageElement) {
                        imageElement.className = selectedBlock.title || selectedBlock.content ? 'block-image' : 'block-image-only';
                    }
                    
                    if (videoWrapper && videoElement) {
                        videoElement.className = selectedBlock.title || selectedBlock.content ? 'block-video' : 'block-video-only';
                    }
                    
                    updateBlockSize(selectedBlock.element);
                    
                    editPanel.style.display = 'none';
                    selectedBlock = null;
                    
                    setUnsavedState();
                }
            });
            
            deleteBlockBtn.addEventListener('click', function() {
                if (selectedBlock) {
                    selectedBlock.element.remove();
                    
                    const connectionsToRemove = connections.filter(conn => 
                        conn.from === selectedBlock.id || conn.to === selectedBlock.id
                    );
                    
                    connectionsToRemove.forEach(conn => {
                        conn.element.remove();
                        const index = connections.indexOf(conn);
                        if (index !== -1) connections.splice(index, 1);
                    });
                    
                    const index = blocks.indexOf(selectedBlock);
                    if (index !== -1) blocks.splice(index, 1);
                    
                    editPanel.style.display = 'none';
                    selectedBlock = null;
                    
                    setUnsavedState();
                }
            });
            
            cancelEditBtn.addEventListener('click', function() {
                editPanel.style.display = 'none';
                selectedBlock = null;
            });
            
            saveProjectBtn.addEventListener('click', function() {
                const projectData = {
                    blocks: blocks.map(block => ({
                        id: block.id,
                        title: block.title,
                        content: block.content,
                        left: block.element.style.left,
                        top: block.element.style.top,
                        mediaType: block.mediaType,
                        media: block.media,
                        mediaWidth: block.mediaWidth,
                        mediaHeight: block.mediaHeight,
                        borderColor: block.borderColor,
                        borderWidth: block.borderWidth,
                        backgroundColor: block.backgroundColor,
                        fontFamily: block.fontFamily,
                        headerColor: block.headerColor,
                        headerFontWeight: block.headerFontWeight,
                        headerFontStyle: block.headerFontStyle,
                        headerTextDecoration: block.headerTextDecoration,
                        showHeaderDivider: block.showHeaderDivider,
                        dividerColor: block.dividerColor,
                        contentColor: block.contentColor,
                        contentFontWeight: block.contentFontWeight,
                        contentFontStyle: block.contentFontStyle,
                        contentTextDecoration: block.contentTextDecoration
                    })),
                    connections: connections.map(conn => ({
                        from: conn.from,
                        to: conn.to,
                        style: conn.style
                    })),
                    gridEnabled: gridEnabled,
                    gridSizeX: gridSizeX,
                    gridSizeY: gridSizeY,
                    canvasScale: canvasScale,
                    scrollLeft: canvasContainer.scrollLeft,
                    scrollTop: canvasContainer.scrollTop,
                    theme: currentTheme,
                    connectorParams: connectorParams
                };
                
                const dataStr = JSON.stringify(projectData);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = 'блок-схема.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                setSavedState();
            });
            
            loadProjectBtn.addEventListener('click', function() {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const projectData = JSON.parse(e.target.result);
                        
                        clearProject();
                        
                        if (projectData.gridEnabled !== undefined) {
                            gridEnabled = projectData.gridEnabled;
                            if (gridEnabled) {
                                toggleGridBtn.textContent = 'Выключить сетку';
                                toggleGridBtn.classList.add('active');
                            } else {
                                toggleGridBtn.textContent = 'Включить сетку';
                                toggleGridBtn.classList.remove('active');
                            }
                            drawGrid();
                        }
                        
                        if (projectData.gridSizeX !== undefined) {
                            gridSizeX = projectData.gridSizeX;
                            gridSizeXInput.value = gridSizeX;
                        }
                        
                        if (projectData.gridSizeY !== undefined) {
                            gridSizeY = projectData.gridSizeY;
                            gridSizeYInput.value = gridSizeY;
                        }
                        
                        if (projectData.canvasScale !== undefined) {
                            canvasScale = projectData.canvasScale;
                            updateCanvasScale();
                        }
                        
                        if (projectData.scrollLeft !== undefined && projectData.scrollTop !== undefined) {
                            canvasContainer.scrollLeft = projectData.scrollLeft;
                            canvasContainer.scrollTop = projectData.scrollTop;
                        }
                        
                        if (projectData.theme !== undefined) {
                            currentTheme = projectData.theme;
                            document.body.classList.toggle('dark-theme', currentTheme === 'dark');
                            themeBtns.forEach(btn => {
                                btn.classList.toggle('active', btn.dataset.theme === currentTheme);
                            });
                        }
                        
                        if (projectData.connectorParams !== undefined) {
                            Object.assign(connectorParams, projectData.connectorParams);
                            
                            // Обновляем значения полей ввода
                            straightWidth.value = connectorParams.straight.width;
                            arrowWidth.value = connectorParams.arrow.width;
                            arrowSize.value = connectorParams.arrow.size;
                            zigzagWidth.value = connectorParams.zigzag.width;
                            zigzagHeight.value = connectorParams.zigzag.height;
                            zigzagSegments.value = connectorParams.zigzag.segments;
                            waveWidth.value = connectorParams.wave.width;
                            waveHeight.value = connectorParams.wave.height;
                            waveCount.value = connectorParams.wave.count;
                            arcWidth.value = connectorParams.arc.width;
                            arcHeight.value = connectorParams.arc.height;
                            loopWidth.value = connectorParams.loop.width;
                            loopHeight.value = connectorParams.loop.height;
                        }
                        
                        projectData.blocks.forEach(blockData => {
                            const blockId = blockData.id;
                            if (blockId >= nextBlockId) nextBlockId = blockId + 1;
                            
                            const block = document.createElement('div');
                            
                            let blockClass = 'block';
                            if (blockData.media && !blockData.title && !blockData.content) {
                                if (blockData.mediaType === 'image') {
                                    blockClass += ' image-only';
                                } else if (blockData.mediaType === 'video') {
                                    blockClass += ' video-only';
                                }
                            }
                            
                            block.className = blockClass;
                            block.id = `block-${blockId}`;
                            block.style.left = blockData.left;
                            block.style.top = blockData.top;
                            
                            block.style.borderColor = blockData.borderColor || '#27ae60';
                            block.style.borderWidth = (blockData.borderWidth || 2) + 'px';
                            block.style.borderStyle = 'solid';
                            block.style.backgroundColor = blockData.backgroundColor || '#ffffff';
                            block.style.fontFamily = blockData.fontFamily || "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
                            
                            let headerStyle = '';
                            if (blockData.showHeaderDivider !== false) {
                                headerStyle = `style="color: ${blockData.headerColor || '#27ae60'}; font-weight: ${blockData.headerFontWeight || 'normal'}; font-style: ${blockData.headerFontStyle || 'normal'}; text-decoration: ${blockData.headerTextDecoration || 'none'}; border-bottom: 1px solid ${blockData.dividerColor || '#eeeeee'}; padding-bottom: 5px; margin-bottom: 8px;"`;
                            } else {
                                headerStyle = `style="color: ${blockData.headerColor || '#27ae60'}; font-weight: ${blockData.headerFontWeight || 'normal'}; font-style: ${blockData.headerFontStyle || 'normal'}; text-decoration: ${blockData.headerTextDecoration || 'none'};"`;
                            }
                            
                            const contentStyle = `style="color: ${blockData.contentColor || '#000000'}; font-weight: ${blockData.contentFontWeight || 'normal'}; font-style: ${blockData.contentFontStyle || 'normal'}; text-decoration: ${blockData.contentTextDecoration || 'none'};"`;
                            
                            let mediaHTML = '';
                            if (blockData.media) {
                                if (blockData.mediaType === 'image') {
                                    const imageClass = blockData.title || blockData.content ? 'block-image' : 'block-image-only';
                                    mediaHTML = `<img class="${imageClass}" src="${blockData.media}">`;
                                } else if (blockData.mediaType === 'video') {
                                    const videoClass = blockData.title || blockData.content ? 'block-video' : 'block-video-only';
                                    mediaHTML = `
                                        <div class="block-video-wrapper">
                                            <video class="${videoClass}" preload="metadata">
                                                <source src="${blockData.media}" type="video/mp4">
                                                Ваш браузер не поддерживает видео.
                                            </video>
                                            <div class="video-controls">
                                                <button class="video-control-btn play-pause">▶️</button>
                                                <button class="video-control-btn mute">🔊</button>
                                                <button class="video-control-btn fullscreen">⛶</button>
                                            </div>
                                        </div>
                                    `;
                                }
                            }
                            
                            block.innerHTML = `
                                ${blockData.title ? `<div class="block-header" ${headerStyle}>${blockData.title}</div>` : ''}
                                ${blockData.content ? `<div class="block-content" ${contentStyle}>${blockData.content}</div>` : ''}
                                ${mediaHTML}
                            `;
                            
                            blocksLayer.appendChild(block);
                            
                            const blockObj = {
                                id: blockId,
                                element: block,
                                title: blockData.title || '',
                                content: blockData.content || '',
                                mediaType: blockData.mediaType || null,
                                media: blockData.media || null,
                                mediaWidth: blockData.mediaWidth || null,
                                mediaHeight: blockData.mediaHeight || null,
                                borderColor: blockData.borderColor || '#27ae60',
                                borderWidth: blockData.borderWidth || 2,
                                backgroundColor: blockData.backgroundColor || '#ffffff',
                                fontFamily: blockData.fontFamily || "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
                                headerColor: blockData.headerColor || '#27ae60',
                                headerFontWeight: blockData.headerFontWeight || 'normal',
                                headerFontStyle: blockData.headerFontStyle || 'normal',
                                headerTextDecoration: blockData.headerTextDecoration || 'none',
                                showHeaderDivider: blockData.showHeaderDivider !== undefined ? blockData.showHeaderDivider : true,
                                dividerColor: blockData.dividerColor || '#eeeeee',
                                contentColor: blockData.contentColor || '#000000',
                                contentFontWeight: blockData.contentFontWeight || 'normal',
                                contentFontStyle: blockData.contentFontStyle || 'normal',
                                contentTextDecoration: blockData.contentTextDecoration || 'none'
                            };
                            
                            blocks.push(blockObj);
                            
                            if (blockData.mediaType === 'video') {
                                setTimeout(() => {
                                    setupVideoControls(block);
                                }, 100);
                            }
                            
                            if (blockData.media) {
                                if (blockData.mediaType === 'image') {
                                    const img = new Image();
                                    img.src = blockData.media;
                                    img.onload = function() {
                                        updateBlockSize(block);
                                        addBlockEventListeners(block, blockId);
                                    };
                                } else {
                                    updateBlockSize(block);
                                    addBlockEventListeners(block, blockId);
                                }
                            } else {
                                updateBlockSize(block);
                                addBlockEventListeners(block, blockId);
                            }
                        });
                        
                        projectData.connections.forEach(connData => {
                            const connection = {
                                from: connData.from,
                                to: connData.to,
                                style: connData.style || 'straight'
                            };
                            createConnection(connection.from, connection.to);
                            // Обновляем стиль соединения
                            const conn = connections[connections.length - 1];
                            conn.style = connection.style;
                            conn.element.className = `connector ${connection.style}`;
                        });
                        
                        updateConnections();
                        setSavedState();
                        
                        showNotification('Проект успешно загружен!');
                    } catch (error) {
                        console.error('Ошибка загрузки проекта:', error);
                        showNotification('Ошибка загрузки проекта!', true);
                    }
                };
                
                reader.readAsText(file);
            });
            
            function clearProject() {
                blocks.forEach(block => block.element.remove());
                connections.forEach(conn => conn.element.remove());
                blocks = [];
                connections = [];
                nextBlockId = 1;
                nextConnectionId = 1;
                setUnsavedState();
                drawGrid();
            }
            
            canvasContainer.addEventListener('mousedown', function(e) {
                if (currentMode === 'move' && !e.target.classList.contains('block')) {
                    isCanvasDragging = true;
                    canvasStartX = e.clientX;
                    canvasStartY = e.clientY;
                    canvasScrollLeft = canvasContainer.scrollLeft;
                    canvasScrollTop = canvasContainer.scrollTop;
                    
                    canvasContainer.style.cursor = 'grabbing';
                    
                    e.preventDefault();
                }
            });
            
            canvasContainer.addEventListener('mousemove', function(e) {
                if (isCanvasDragging) {
                    const dx = e.clientX - canvasStartX;
                    const dy = e.clientY - canvasStartY;
                    
                    canvasContainer.scrollLeft = canvasScrollLeft - dx;
                    canvasContainer.scrollTop = canvasScrollTop - dy;
                    
                    drawGrid();
                    updateConnections();
                    
                    e.preventDefault();
                }
            });
            
            canvasContainer.addEventListener('mouseup', function() {
                if (isCanvasDragging) {
                    isCanvasDragging = false;
                    canvasContainer.style.cursor = 'grab';
                }
            });
            
            canvasContainer.addEventListener('mouseleave', function() {
                if (isCanvasDragging) {
                    isCanvasDragging = false;
                    canvasContainer.style.cursor = 'grab';
                }
            });
            
            canvasContainer.addEventListener('touchstart', function(e) {
                if (currentMode === 'move' && !e.target.classList.contains('block')) {
                    isCanvasDragging = true;
                    const touch = e.touches[0];
                    canvasStartX = touch.clientX;
                    canvasStartY = touch.clientY;
                    canvasScrollLeft = canvasContainer.scrollLeft;
                    canvasScrollTop = canvasContainer.scrollTop;
                    
                    canvasContainer.style.cursor = 'grabbing';
                    
                    e.preventDefault();
                }
            }, { passive: false });
            
            canvasContainer.addEventListener('touchmove', function(e) {
                if (isCanvasDragging) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - canvasStartX;
                    const dy = touch.clientY - canvasStartY;
                    
                    canvasContainer.scrollLeft = canvasScrollLeft - dx;
                    canvasContainer.scrollTop = canvasScrollTop - dy;
                    
                    drawGrid();
                    updateConnections();
                    
                    e.preventDefault();
                }
            }, { passive: false });
            
            canvasContainer.addEventListener('touchend', function() {
                if (isCanvasDragging) {
                    isCanvasDragging = false;
                    canvasContainer.style.cursor = 'grab';
                }
            });
            
            clearAllBtn.addEventListener('click', function() {
                if (confirm('Вы уверены, что хотите очистить весь проект? Все несохраненные данные будут потеряны.')) {
                    clearProject();
                }
            });
            
            // ИСПРАВЛЕННЫЙ КОД ЭКСПОРТА В PNG
            exportBtn.addEventListener('click', function() {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                document.head.appendChild(script);

                script.onload = function() {
                    // Находим границы всех элементов
                    let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;

                    // Границы блоков
                    blocks.forEach(block => {
                        const left = parseInt(block.element.style.left);
                        const top = parseInt(block.element.style.top);
                        const width = block.element.offsetWidth;
                        const height = block.element.offsetHeight;

                        minX = Math.min(minX, left);
                        minY = Math.min(minY, top);
                        maxX = Math.max(maxX, left + width);
                        maxY = Math.max(maxY, top + height);
                    });

                    // Границы соединений
                    connections.forEach(conn => {
                        const fromBlock = blocks.find(b => b.id === conn.from);
                        const toBlock = blocks.find(b => b.id === conn.to);
                        if (fromBlock && toBlock) {
                            const fromX = parseInt(fromBlock.element.style.left) + fromBlock.element.offsetWidth / 2;
                            const fromY = parseInt(fromBlock.element.style.top) + fromBlock.element.offsetHeight / 2;
                            const toX = parseInt(toBlock.element.style.left) + toBlock.element.offsetWidth / 2;
                            const toY = parseInt(toBlock.element.style.top) + toBlock.element.offsetHeight / 2;

                            minX = Math.min(minX, fromX, toX);
                            minY = Math.min(minY, fromY, toY);
                            maxX = Math.max(maxX, fromX, toX);
                            maxY = Math.max(maxY, fromY, toY);
                        }
                    });

                    // Добавляем отступы
                    const padding = 50;
                    minX = blocks.length ? minX - padding : 0;
                    minY = blocks.length ? minY - padding : 0;
                    maxX = blocks.length ? maxX + padding : 500;
                    maxY = blocks.length ? maxY + padding : 500;

                    // Создаем временный контейнер для экспорта
                    const exportContainer = document.createElement('div');
                    exportContainer.style.position = 'absolute';
                    exportContainer.style.left = '-9999px';
                    exportContainer.style.top = '0';
                    exportContainer.style.width = (maxX - minX) + 'px';
                    exportContainer.style.height = (maxY - minY) + 'px';
                    exportContainer.style.backgroundColor = currentTheme === 'dark' ? '#34495e' : '#f9f9f9';
                    exportContainer.style.overflow = 'visible';
                    document.body.appendChild(exportContainer);

                    // Копируем блоки в контейнер экспорта
                    blocks.forEach(block => {
                        const blockClone = block.element.cloneNode(true);
                        const left = parseInt(block.element.style.left) - minX;
                        const top = parseInt(block.element.style.top) - minY;
                        
                        blockClone.style.position = 'absolute';
                        blockClone.style.left = left + 'px';
                        blockClone.style.top = top + 'px';
                        blockClone.style.transform = 'scale(1)';
                        blockClone.style.zIndex = '10';
                        
                        exportContainer.appendChild(blockClone);
                    });

                    // Создаем canvas для рисования соединений
                    const connectionsCanvas = document.createElement('canvas');
                    connectionsCanvas.width = maxX - minX;
                    connectionsCanvas.height = maxY - minY;
                    connectionsCanvas.style.position = 'absolute';
                    connectionsCanvas.style.left = '0';
                    connectionsCanvas.style.top = '0';
                    connectionsCanvas.style.zIndex = '5';
                    
                    const ctx = connectionsCanvas.getContext('2d');
                    
                    // Рисуем сетку если включена
                    if (gridEnabled) {
                        ctx.strokeStyle = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(200, 200, 200, 0.3)';
                        ctx.lineWidth = 1;
                        
                        for (let x = 0; x < maxX - minX; x += gridSizeX) {
                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, maxY - minY);
                            ctx.stroke();
                        }
                        
                        for (let y = 0; y < maxY - minY; y += gridSizeY) {
                            ctx.beginPath();
                            ctx.moveTo(0, y);
                            ctx.lineTo(maxX - minX, y);
                            ctx.stroke();
                        }
                    }
                    
                    // Рисуем все соединения
                    connections.forEach(conn => {
                        const fromBlock = blocks.find(b => b.id === conn.from);
                        const toBlock = blocks.find(b => b.id === conn.to);
                        
                        if (fromBlock && toBlock) {
                            const fromX = parseInt(fromBlock.element.style.left) + fromBlock.element.offsetWidth / 2 - minX;
                            const fromY = parseInt(fromBlock.element.style.top) + fromBlock.element.offsetHeight / 2 - minY;
                            const toX = parseInt(toBlock.element.style.left) + toBlock.element.offsetWidth / 2 - minX;
                            const toY = parseInt(toBlock.element.style.top) + toBlock.element.offsetHeight / 2 - minY;
                            
                            ctx.strokeStyle = '#27ae60';
                            ctx.lineWidth = connectorParams[conn.style].width || 3;
                            ctx.lineCap = 'round';
                            
                            // Рисуем соединение в зависимости от стиля
                            switch(conn.style) {
                                case 'straight':
                                    ctx.beginPath();
                                    ctx.moveTo(fromX, fromY);
                                    ctx.lineTo(toX, toY);
                                    ctx.stroke();
                                    break;
                                    
                                case 'arrow':
                                    ctx.beginPath();
                                    ctx.moveTo(fromX, fromY);
                                    ctx.lineTo(toX, toY);
                                    ctx.stroke();
                                    
                                    // Рисуем стрелку
                                    const angle = Math.atan2(toY - fromY, toX - fromX);
                                    const arrowSize = connectorParams.arrow.size || 10;
                                    const arrowX = toX - arrowSize * Math.cos(angle);
                                    const arrowY = toY - arrowSize * Math.sin(angle);
                                    
                                    ctx.fillStyle = '#27ae60';
                                    ctx.beginPath();
                                    ctx.moveTo(toX, toY);
                                    ctx.lineTo(
                                        arrowX + arrowSize * Math.cos(angle - Math.PI/6),
                                        arrowY + arrowSize * Math.sin(angle - Math.PI/6)
                                    );
                                    ctx.lineTo(
                                        arrowX + arrowSize * Math.cos(angle + Math.PI/6),
                                        arrowY + arrowSize * Math.sin(angle + Math.PI/6)
                                    );
                                    ctx.closePath();
                                    ctx.fill();
                                    break;
                                    
                                case 'zigzag':
                                    const segments = connectorParams.zigzag.segments || 8;
                                    const stepX = (toX - fromX) / segments;
                                    const stepY = (toY - fromY) / segments;
                                    const zigzagHeight = connectorParams.zigzag.height || 20;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(fromX, fromY);
                                    for (let i = 1; i <= segments; i++) {
                                        const x = fromX + i * stepX;
                                        const y = fromY + i * stepY;
                                        if (i % 2 === 0) {
                                            ctx.lineTo(x, y - zigzagHeight);
                                        } else {
                                            ctx.lineTo(x, y + zigzagHeight);
                                        }
                                    }
                                    ctx.lineTo(toX, toY);
                                    ctx.stroke();
                                    break;
                                    
                                case 'wave':
                                    const waveCount = connectorParams.wave.count || 6;
                                    const waveSegments = waveCount * 2;
                                    const waveStepX = (toX - fromX) / waveSegments;
                                    const waveStepY = (toY - fromY) / waveSegments;
                                    const waveHeight = connectorParams.wave.height || 30;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(fromX, fromY);
                                    for (let i = 1; i <= waveSegments; i++) {
                                        const x = fromX + i * waveStepX;
                                        const y = fromY + i * waveStepY;
                                        const cp1x = x - waveStepX/2;
                                        const cp1y = y + (i % 2 === 0 ? -waveHeight : waveHeight);
                                        const cp2x = x + waveStepX/2;
                                        const cp2y = y + (i % 2 === 0 ? -waveHeight : waveHeight);
                                        
                                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                                    }
                                    ctx.stroke();
                                    break;
                                    
                                case 'arc':
                                    const arcHeight = connectorParams.arc.height || 50;
                                    const midX = (fromX + toX) / 2;
                                    const midY = (fromY + toY) / 2 - arcHeight;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(fromX, fromY);
                                    ctx.quadraticCurveTo(midX, midY, toX, toY);
                                    ctx.stroke();
                                    break;
                                    
                                case 'loop':
                                    const loopHeight = connectorParams.loop.height || 80;
                                    const loopWidth = Math.abs(toX - fromX) / 2;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(fromX, fromY);
                                    ctx.bezierCurveTo(
                                        fromX + loopWidth, fromY,
                                        toX - loopWidth, toY - loopHeight,
                                        toX, toY
                                    );
                                    ctx.stroke();
                                    break;
                                    
                                default:
                                    ctx.beginPath();
                                    ctx.moveTo(fromX, fromY);
                                    ctx.lineTo(toX, toY);
                                    ctx.stroke();
                            }
                        }
                    });
                    
                    // Добавляем canvas с соединениями в контейнер
                    exportContainer.appendChild(connectionsCanvas);

                    // Экспортируем весь контейнер
                    html2canvas(exportContainer, {
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: currentTheme === 'dark' ? '#34495e' : '#f9f9f9'
                    }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = 'блок-схема.png';
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                        
                        // Очищаем
                        document.body.removeChild(exportContainer);
                        document.head.removeChild(script);
                        
                        showNotification('Изображение успешно экспортировано!');
                    }).catch(error => {
                        console.error('Ошибка экспорта:', error);
                        showNotification('Ошибка при экспорте изображения!', true);
                        document.body.removeChild(exportContainer);
                        document.head.removeChild(script);
                    });
                };
                
                script.onerror = function() {
                    showNotification('Ошибка загрузки библиотеки для экспорта!', true);
                };
            });

            zoomInBtnSidebar.addEventListener('click', function() {
                canvasScale = Math.min(canvasScale + 0.1, 2);
                updateCanvasScale();
                setUnsavedState();
            });

            zoomOutBtnSidebar.addEventListener('click', function() {
                canvasScale = Math.max(canvasScale - 0.1, 0.5);
                updateCanvasScale();
                setUnsavedState();
            });

            resetViewBtnSidebar.addEventListener('click', function() {
                canvasScale = 1;
                canvasContainer.scrollLeft = 0;
                canvasContainer.scrollTop = 0;
                updateCanvasScale();
                setUnsavedState();
            });

            function updateCanvasScale() {
                canvas.style.transform = `scale(${canvasScale})`;
                zoomLevelDisplaySidebar.textContent = `${Math.round(canvasScale * 100)}%`;
                resizeGridCanvas();
                updateConnections();
            }

            function showNotification(message, isError = false) {
                const notification = document.createElement('div');
                notification.className = `notification ${isError ? 'error' : ''}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.classList.add('show');
                }, 10);

                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        notification.remove();
                    }, 300);
                }, 3000);
            }

            function setUnsavedState() {
                isSaved = false;
                saveStatus.textContent = 'Не сохранено';
                saveStatus.classList.remove('status-active');
                saveStatus.classList.add('status-inactive');
            }

            function setSavedState() {
                isSaved = true;
                saveStatus.textContent = 'Сохранено';
                saveStatus.classList.remove('status-inactive');
                saveStatus.classList.add('status-active');
            }

            function updateSaveStatus() {
                if (isSaved) {
                    saveStatus.textContent = 'Сохранено';
                    saveStatus.classList.add('status-active');
                    saveStatus.classList.remove('status-inactive');
                } else {
                    saveStatus.textContent = 'Не сохранено';
                    saveStatus.classList.add('status-inactive');
                    saveStatus.classList.remove('status-active');
                }
            }

            drawGrid();
            updateConnections();
        });
    </script> 
</body>
</html>
